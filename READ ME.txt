# AI ë“œë¼ë§ˆ ì™„ì „ ìë™í™” ì‹œìŠ¤í…œ - ê°œë°œ ì§€ì‹œì„œ

## 1. ì‹œìŠ¤í…œ ê°œìš”

### 1.1 í”„ë¡œì íŠ¸ëª…
- **AI Drama Automation System (AIDAS)**

### 1.2 ëª©ì 
- í•˜ë£¨ 10ê°œì˜ AI ë“œë¼ë§ˆë¥¼ ì™„ì „ ìë™ìœ¼ë¡œ ì œì‘í•˜ì—¬ YouTubeì— ì—…ë¡œë“œí•˜ëŠ” ì‹œìŠ¤í…œ

### 1.3 í•µì‹¬ ìš”êµ¬ì‚¬í•­
- 24ì‹œê°„ ë¬´ì¸ ìš´ì˜
- ì¼ì¼ 10ê°œ ì—í”¼ì†Œë“œ ìë™ ìƒì‚°
- ì—ëŸ¬ ë°œìƒ ì‹œ ìë™ ë³µêµ¬
- ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ê°€ëŠ¥

---

## 2. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### 2.1 ì „ì²´ êµ¬ì¡°ë„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ë©”ì¸ ì»¨íŠ¸ë¡¤ëŸ¬                          â”‚
â”‚              (Main Controller Server)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚               â”‚               â”‚
        â–¼               â–¼               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ì‘ì—… í      â”‚ â”‚  API ê´€ë¦¬ì   â”‚ â”‚  ëª¨ë‹ˆí„°ë§     â”‚
â”‚  (Queue)     â”‚ â”‚  (Manager)    â”‚ â”‚  (Monitor)    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                â”‚                â”‚
       â–¼                â–¼                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  ì›Œì»¤ í”„ë¡œì„¸ìŠ¤                      â”‚
â”‚  (Script â†’ Voice â†’ Avatar â†’ Edit â†’ Upload)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ê¸°ìˆ  ìŠ¤íƒ
```yaml
Backend:
  - Language: Python 3.9+
  - Framework: FastAPI
  - Task Queue: Celery + Redis
  - Database: PostgreSQL
  - Container: Docker

APIs:
  - Script Generation: OpenAI GPT-4
  - Voice Generation: ElevenLabs
  - Avatar Video: HeyGen
  - Video Upload: YouTube Data API v3

Tools:
  - Video Processing: FFmpeg, MoviePy
  - Image Processing: Pillow
  - Scheduling: APScheduler
```

---

## 3. ìƒì„¸ ê°œë°œ ì§€ì‹œì„œ

### 3.1 í”„ë¡œì íŠ¸ êµ¬ì¡°
```
ai-drama-system/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py                 # FastAPI ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜
â”‚   â”œâ”€â”€ config.py               # ì„¤ì • ê´€ë¦¬
â”‚   â”œâ”€â”€ database.py             # ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°
â”‚   â”‚
â”‚   â”œâ”€â”€ models/                 # ë°ì´í„°ë² ì´ìŠ¤ ëª¨ë¸
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ drama.py            # ë“œë¼ë§ˆ ì‹œë¦¬ì¦ˆ ëª¨ë¸
â”‚   â”‚   â”œâ”€â”€ episode.py          # ì—í”¼ì†Œë“œ ëª¨ë¸
â”‚   â”‚   â”œâ”€â”€ character.py        # ìºë¦­í„° ëª¨ë¸
â”‚   â”‚   â””â”€â”€ job.py              # ì‘ì—… í ëª¨ë¸
â”‚   â”‚
â”‚   â”œâ”€â”€ api/                    # API ì—”ë“œí¬ì¸íŠ¸
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ drama.py            # ë“œë¼ë§ˆ ê´€ë¦¬ API
â”‚   â”‚   â”œâ”€â”€ episode.py          # ì—í”¼ì†Œë“œ ê´€ë¦¬ API
â”‚   â”‚   â”œâ”€â”€ job.py              # ì‘ì—… ê´€ë¦¬ API
â”‚   â”‚   â””â”€â”€ stats.py            # í†µê³„ API
â”‚   â”‚
â”‚   â”œâ”€â”€ core/                   # í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ script_generator.py # ëŒ€ë³¸ ìƒì„±
â”‚   â”‚   â”œâ”€â”€ voice_generator.py  # ìŒì„± ìƒì„±
â”‚   â”‚   â”œâ”€â”€ avatar_generator.py # ì•„ë°”íƒ€ ì˜ìƒ ìƒì„±
â”‚   â”‚   â”œâ”€â”€ video_editor.py     # ì˜ìƒ í¸ì§‘
â”‚   â”‚   â””â”€â”€ youtube_uploader.py # YouTube ì—…ë¡œë“œ
â”‚   â”‚
â”‚   â”œâ”€â”€ workers/                # Celery ì›Œì»¤
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ tasks.py            # ë¹„ë™ê¸° ì‘ì—… ì •ì˜
â”‚   â”‚   â””â”€â”€ scheduler.py        # ìŠ¤ì¼€ì¤„ëŸ¬
â”‚   â”‚
â”‚   â””â”€â”€ utils/                  # ìœ í‹¸ë¦¬í‹°
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ logger.py           # ë¡œê¹…
â”‚       â”œâ”€â”€ exceptions.py       # ì»¤ìŠ¤í…€ ì˜ˆì™¸
â”‚       â””â”€â”€ helpers.py          # í—¬í¼ í•¨ìˆ˜
â”‚
â”œâ”€â”€ tests/                      # í…ŒìŠ¤íŠ¸
â”œâ”€â”€ migrations/                 # ë°ì´í„°ë² ì´ìŠ¤ ë§ˆì´ê·¸ë ˆì´ì…˜
â”œâ”€â”€ static/                     # ì •ì  íŒŒì¼
â”œâ”€â”€ templates/                  # í…œí”Œë¦¿ íŒŒì¼docker-compose.yml
â”œâ”€â”€ docker-compose.yml          # Docker ì„¤ì •
â”œâ”€â”€ requirements.txt            # ì˜ì¡´ì„±
â””â”€â”€ README.md                   # í”„ë¡œì íŠ¸ ë¬¸ì„œ
```

---

## 4. í•µì‹¬ ëª¨ë“ˆ ê°œë°œ ì§€ì‹œ

### 4.1 ëŒ€ë³¸ ìƒì„± ëª¨ë“ˆ (script_generator.py) - ì‹œë¦¬ì¦ˆ ì—°ì†ì„± ê°•í™”

#### 4.1.1 í´ë˜ìŠ¤ êµ¬ì¡°
```python
class ScriptGenerator:
    def __init__(self):
        self.openai_client = OpenAI(api_key=OPENAI_API_KEY)
        self.drama_config = self.load_drama_config()
        self.story_memory = StoryMemory()  # ìŠ¤í† ë¦¬ ì—°ì†ì„± ê´€ë¦¬
        self.character_tracker = CharacterTracker()  # ìºë¦­í„° ì¶”ì 
    
    def create_new_series(self, series_config: Dict) -> Dict:
        """
        ìƒˆë¡œìš´ ë“œë¼ë§ˆ ì‹œë¦¬ì¦ˆ ìƒì„±
        
        Args:
            series_config: {
                "title": "ì²«ì‚¬ë‘ì€ ì²˜ìŒì´ë¼ì„œ",
                "genre": "ë¡œë§¨í‹± ì½”ë¯¸ë””",
                "total_episodes": 16,
                "episode_duration": 10,
                "main_theme": "ì²«ì‚¬ë‘ì˜ ì„¤ë ˜ê³¼ ì„±ì¥",
                "target_audience": "20-30ëŒ€ ì—¬ì„±"
            }
        """
        # 1. ì „ì²´ ì‹œë¦¬ì¦ˆ í”Œë¡¯ ìƒì„±
        series_plot = self.generate_series_plot(series_config)
        
        # 2. ì£¼ìš” ìºë¦­í„° ì„¤ì •
        characters = self.create_character_profiles(series_config)
        
        # 3. ì—í”¼ì†Œë“œë³„ ê°œìš” ìƒì„±
        episode_outlines = self.generate_episode_outlines(
            series_plot, 
            series_config["total_episodes"]
        )
        
        # 4. ì‹œë¦¬ì¦ˆ ë°ì´í„° ì €ì¥
        series_data = {
            "series_id": generate_uuid(),
            "config": series_config,
            "plot": series_plot,
            "characters": characters,
            "episode_outlines": episode_outlines,
            "story_arc": self.create_story_arc(series_plot)
        }
        
        self.story_memory.save_series(series_data)
        return series_data
    
    def generate_episode_script(self, series_id: str, episode_number: int) -> Dict:
        """
        ì—°ì†ì„± ìˆëŠ” ì—í”¼ì†Œë“œ ëŒ€ë³¸ ìƒì„±
        """
        # 1. ì‹œë¦¬ì¦ˆ ì •ë³´ ë¡œë“œ
        series = self.story_memory.get_series(series_id)
        
        # 2. ì´ì „ ì—í”¼ì†Œë“œ ì •ë³´ ìˆ˜ì§‘
        previous_episodes = self.story_memory.get_previous_episodes(
            series_id, 
            episode_number
        )
        
        # 3. í˜„ì¬ ì—í”¼ì†Œë“œì— í•„ìš”í•œ ì»¨í…ìŠ¤íŠ¸ êµ¬ì„±
        context = self.build_episode_context(
            series,
            episode_number,
            previous_episodes
        )
        
        # 4. ì—í”¼ì†Œë“œ ëŒ€ë³¸ ìƒì„±
        script = self.generate_script_with_context(context)
        
        # 5. ì—°ì†ì„± ê²€ì¦
        self.validate_continuity(script, context)
        
        # 6. ìŠ¤í† ë¦¬ ë©”ëª¨ë¦¬ ì—…ë°ì´íŠ¸
        self.story_memory.update_episode(series_id, episode_number, script)
        
        return script
    
    def build_episode_context(self, series: Dict, episode_num: int, previous: List) -> Dict:
        """ì—í”¼ì†Œë“œ ì»¨í…ìŠ¤íŠ¸ êµ¬ì„±"""
        return {
            "series_info": series["config"],
            "overall_plot": series["plot"],
            "current_episode_outline": series["episode_outlines"][episode_num - 1],
            "character_states": self.character_tracker.get_current_states(series["series_id"]),
            "previous_events": self.summarize_previous_events(previous),
            "unresolved_plots": self.get_unresolved_plots(previous),
            "relationships": self.character_tracker.get_relationship_status(series["series_id"]),
            "story_progress": self.calculate_story_progress(episode_num, series["config"]["total_episodes"])
        }
```

#### 4.1.2 ìŠ¤í† ë¦¬ ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œ
```python
class StoryMemory:
    """ë“œë¼ë§ˆ ì‹œë¦¬ì¦ˆì˜ ì—°ì†ì„±ì„ ê´€ë¦¬í•˜ëŠ” ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.db = Database()
    
    def save_series(self, series_data: Dict):
        """ì‹œë¦¬ì¦ˆ ì „ì²´ ì •ë³´ ì €ì¥"""
        self.db.insert("series_memory", {
            "series_id": series_data["series_id"],
            "plot_summary": series_data["plot"],
            "character_profiles": json.dumps(series_data["characters"]),
            "episode_outlines": json.dumps(series_data["episode_outlines"]),
            "story_arc": json.dumps(series_data["story_arc"])
        })
    
    def get_previous_episodes(self, series_id: str, current_episode: int) -> List[Dict]:
        """ì´ì „ ì—í”¼ì†Œë“œ ì •ë³´ ì¡°íšŒ"""
        return self.db.query("""
            SELECT episode_number, summary, key_events, character_developments
            FROM episodes
            WHERE series_id = %s AND episode_number < %s
            ORDER BY episode_number DESC
            LIMIT 5
        """, (series_id, current_episode))
    
    def update_episode(self, series_id: str, episode_num: int, script: Dict):
        """ì—í”¼ì†Œë“œ ì •ë³´ ì—…ë°ì´íŠ¸"""
        # 1. ì£¼ìš” ì‚¬ê±´ ì¶”ì¶œ
        key_events = self.extract_key_events(script)
        
        # 2. ìºë¦­í„° ë°œì „ì‚¬í•­ ì¶”ì¶œ
        character_developments = self.extract_character_developments(script)
        
        # 3. ê´€ê³„ ë³€í™” ì¶”ì¶œ
        relationship_changes = self.extract_relationship_changes(script)
        
        # 4. ë¯¸í•´ê²° í”Œë¡¯ ì—…ë°ì´íŠ¸
        unresolved_plots = self.update_unresolved_plots(script)
        
        self.db.update("episodes", {
            "summary": self.generate_episode_summary(script),
            "key_events": json.dumps(key_events),
            "character_developments": json.dumps(character_developments),
            "relationship_changes": json.dumps(relationship_changes),
            "unresolved_plots": json.dumps(unresolved_plots)
        }, {"series_id": series_id, "episode_number": episode_num})
```

#### 4.1.3 ìºë¦­í„° ì¶”ì  ì‹œìŠ¤í…œ - 10ëª… ì´ìƒ ìºë¦­í„° ê´€ë¦¬
```python
class CharacterTracker:
    """ìºë¦­í„°ì˜ ìƒíƒœì™€ ë°œì „ì„ ì¶”ì í•˜ëŠ” ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.db = Database()
        self.min_characters = 10  # ìµœì†Œ ìºë¦­í„° ìˆ˜
        self.voice_manager = VoiceCharacterManager()
    
    def create_character_profiles(self, series_config: Dict) -> List[Dict]:
        """ì‹œë¦¬ì¦ˆ ì‹œì‘ ì‹œ ìºë¦­í„° í”„ë¡œí•„ ìƒì„± (ìµœì†Œ 10ëª…)"""
        characters = []
        
        # 1. í•µì‹¬ ì£¼ì¸ê³µ (2ëª…)
        main_characters = [
            {
                "id": "CHAR001",
                "name": "ê°•ë¯¼ì¤€",
                "role": "ì£¼ì¸ê³µ(ë‚¨)",
                "importance": "main",
                "age": 28,
                "occupation": "ìŠ¤íƒ€íŠ¸ì—… CEO",
                "personality": ["ì—´ì •ì ", "ë‹¤ì •í•¨", "ë•Œë¡œëŠ” ì¶©ë™ì "],
                "background": "ëŒ€ê¸°ì—…ì„ ê·¸ë§Œë‘ê³  ì°½ì—…í•œ ì²­ë…„",
                "goals": ["ì‚¬ì—… ì„±ê³µ", "ì§„ì •í•œ ì‚¬ë‘ ì°¾ê¸°"],
                "secrets": ["ê³¼ê±° ì‹¤íŒ¨í•œ ì‚¬ì—…ìœ¼ë¡œ ì¸í•œ íŠ¸ë¼ìš°ë§ˆ"],
                "voice_profile": {
                    "gender": "male",
                    "age_group": "young_adult",
                    "tone": "warm",
                    "speaking_style": "confident"
                },
                "appearance_profile": {
                    "avatar_type": "professional_male",
                    "age_appearance": "late_20s",
                    "style": "modern_casual"
                }
            },
            {
                "id": "CHAR002",
                "name": "ì´ìˆ˜ì§„",
                "role": "ì£¼ì¸ê³µ(ì—¬)",
                "importance": "main",
                "age": 26,
                "occupation": "ì›¹íˆ° ì‘ê°€",
                "personality": ["ì°½ì˜ì ", "ë…ë¦½ì ", "ë‚´í–¥ì "],
                "background": "ì¸ê¸° ì›¹íˆ° ì‘ê°€ì§€ë§Œ ëŒ€ì¸ê´€ê³„ì— ì„œíˆ¼",
                "goals": ["ë” í° ì„±ê³µ", "ìì‹ ê° ì°¾ê¸°"],
                "secrets": ["ìœ ëª… ì‘ê°€ì¸ ê²ƒì„ ìˆ¨ê¸°ê³  ìˆìŒ"],
                "voice_profile": {
                    "gender": "female",
                    "age_group": "young_adult",
                    "tone": "soft",
                    "speaking_style": "thoughtful"
                }
            }
        ]
        
        # 2. ì£¼ìš” ì¡°ì—° (4ëª…)
        supporting_characters = [
            {
                "id": "CHAR003",
                "name": "ë°•ì§€í˜¸",
                "role": "ë¯¼ì¤€ì˜ ì ˆì¹œ/ì¡°ì–¸ì",
                "importance": "major_supporting",
                "age": 29,
                "occupation": "ë³€í˜¸ì‚¬",
                "personality": ["ì´ì„±ì ", "ì¶©ì‹¤í•¨", "ë•Œë¡œëŠ” ëƒ‰ì •í•¨"],
                "voice_profile": {
                    "gender": "male",
                    "age_group": "adult",
                    "tone": "serious",
                    "speaking_style": "articulate"
                }
            },
            {
                "id": "CHAR004",
                "name": "ê¹€í•˜ëŠ˜",
                "role": "ìˆ˜ì§„ì˜ ë² í”„",
                "importance": "major_supporting",
                "age": 25,
                "occupation": "ì¹´í˜ ì‚¬ì¥",
                "personality": ["ë°ìŒ", "ìˆ˜ë‹¤ìŠ¤ëŸ¬ì›€", "ë”°ëœ»í•¨"],
                "voice_profile": {
                    "gender": "female",
                    "age_group": "young_adult",
                    "tone": "cheerful",
                    "speaking_style": "energetic"
                }
            },
            {
                "id": "CHAR005",
                "name": "ì°¨ì„±í›ˆ",
                "role": "ë¯¼ì¤€ì˜ ë¼ì´ë²Œ/íˆ¬ìì",
                "importance": "major_supporting",
                "age": 35,
                "occupation": "ë²¤ì²˜íˆ¬ìì",
                "personality": ["ì•¼ì‹¬ì°¸", "ëƒ‰ì² í•¨", "ì „ëµì "],
                "secrets": ["ìˆ˜ì§„ì—ê²Œ ê´€ì‹¬ ìˆìŒ"],
                "voice_profile": {
                    "gender": "male",
                    "age_group": "adult",
                    "tone": "authoritative",
                    "speaking_style": "calculating"
                }
            },
            {
                "id": "CHAR006",
                "name": "í•œì†Œì˜",
                "role": "ë¯¼ì¤€ì˜ ì „ ì—¬ìì¹œêµ¬",
                "importance": "major_supporting",
                "age": 27,
                "occupation": "íŒ¨ì…˜ ë””ìì´ë„ˆ",
                "personality": ["ì„¸ë ¨ë¨", "ìì‹ ê°", "ë…ì ìš•"],
                "voice_profile": {
                    "gender": "female",
                    "age_group": "young_adult",
                    "tone": "sophisticated",
                    "speaking_style": "assertive"
                }
            }
        ]
        
        # 3. ê°€ì¡± êµ¬ì„±ì› (4ëª…)
        family_characters = [
            {
                "id": "CHAR007",
                "name": "ê°•ì •í˜¸",
                "role": "ë¯¼ì¤€ì˜ ì•„ë²„ì§€",
                "importance": "supporting",
                "age": 58,
                "occupation": "ì€í‡´í•œ ëŒ€ê¸°ì—… ì„ì›",
                "personality": ["ì—„ê²©í•¨", "ì „í†µì ", "ê°€ì¡±ì• "],
                "voice_profile": {
                    "gender": "male",
                    "age_group": "senior",
                    "tone": "deep",
                    "speaking_style": "formal"
                }
            },
            {
                "id": "CHAR008",
                "name": "ì´ë¯¸ê²½",
                "role": "ìˆ˜ì§„ì˜ ì–´ë¨¸ë‹ˆ",
                "importance": "supporting",
                "age": 52,
                "occupation": "ì£¼ë¶€",
                "personality": ["ë”°ëœ»í•¨", "ê±±ì •ë§ìŒ", "í—Œì‹ ì "],
                "voice_profile": {
                    "gender": "female",
                    "age_group": "middle_age",
                    "tone": "caring",
                    "speaking_style": "gentle"
                }
            },
            {
                "id": "CHAR009",
                "name": "ê°•ë¯¼ì„œ",
                "role": "ë¯¼ì¤€ì˜ ì—¬ë™ìƒ",
                "importance": "supporting",
                "age": 24,
                "occupation": "ëŒ€í•™ì›ìƒ",
                "personality": ["ë˜‘ë˜‘í•¨", "ë°œë„í•¨", "ì˜¤ì§€ë–"],
                "voice_profile": {
                    "gender": "female",
                    "age_group": "young_adult",
                    "tone": "bright",
                    "speaking_style": "casual"
                }
            },
            {
                "id": "CHAR010",
                "name": "ì´ì¤€í˜¸",
                "role": "ìˆ˜ì§„ì˜ ë‚¨ë™ìƒ",
                "importance": "supporting",
                "age": 22,
                "occupation": "ëŒ€í•™ìƒ",
                "personality": ["ê²Œì„ë•í›„", "ë‚´í–¥ì ", "ëˆ„ë‚˜ë°”ë¼ê¸°"],
                "voice_profile": {
                    "gender": "male",
                    "age_group": "young",
                    "tone": "youthful",
                    "speaking_style": "shy"
                }
            }
        ]
        
        # 4. í™•ì¥ ìºë¦­í„° ìë™ ìƒì„± (í•„ìš”ì‹œ ì¶”ê°€)
        additional_characters = self.generate_additional_characters(series_config)
        
        # ì „ì²´ ìºë¦­í„° í†µí•©
        characters = main_characters + supporting_characters + family_characters + additional_characters
        
        # 5. ìºë¦­í„°ë³„ ìŒì„±/ì•„ë°”íƒ€ í• ë‹¹
        for char in characters:
            char["voice_assignment"] = self.voice_manager.assign_voice(char)
            char["avatar_assignment"] = self.assign_avatar_strategy(char)
        
        # ê° ìºë¦­í„° ì €ì¥
        for char in characters:
            self.save_character(series_config["series_id"], char)
        
        return characters
    
    def generate_additional_characters(self, series_config: Dict) -> List[Dict]:
        """ì¥ë¥´ì™€ ìŠ¤í† ë¦¬ì— ë§ëŠ” ì¶”ê°€ ìºë¦­í„° ìë™ ìƒì„±"""
        additional = []
        
        if series_config["genre"] == "romance":
            additional.extend([
                {
                    "id": "CHAR011",
                    "name": "ì •ìœ ì§„",
                    "role": "ì¹´í˜ ì•Œë°”ìƒ",
                    "importance": "minor",
                    "personality": ["ìˆ˜ì¤ìŒ", "ê´€ì°°ë ¥"],
                    "voice_profile": {"gender": "female", "age_group": "young"}
                },
                {
                    "id": "CHAR012", 
                    "name": "ê¹€ê³¼ì¥",
                    "role": "ë¯¼ì¤€ íšŒì‚¬ ì§ì›",
                    "importance": "minor",
                    "personality": ["ì„±ì‹¤í•¨", "ì¶©ì„±ì‹¬"],
                    "voice_profile": {"gender": "male", "age_group": "middle_age"}
                }
            ])
        
        return additional
    
    def assign_avatar_strategy(self, character: Dict) -> Dict:
        """ìºë¦­í„° ì¤‘ìš”ë„ì— ë”°ë¥¸ ì•„ë°”íƒ€ ì „ëµ"""
        if character["importance"] == "main":
            return {
                "type": "full_avatar",
                "avatar_id": self.get_best_matching_avatar(character),
                "fallback": "avatar_b"
            }
        elif character["importance"] == "major_supporting":
            return {
                "type": "partial_avatar",
                "strategy": "side_profile_or_back",
                "voice_only_scenes": 0.3  # 30%ëŠ” ìŒì„±ë§Œ
            }
        else:
            return {
                "type": "voice_only",
                "visual_representation": "static_image_or_text"
            }
        
    
class VoiceCharacterManager:
    """ë‹¤ìˆ˜ ìºë¦­í„° ìŒì„± ê´€ë¦¬ ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.voice_pool = self.load_available_voices()
        self.voice_assignments = {}
    
    def assign_voice(self, character: Dict) -> Dict:
        """ìºë¦­í„°ë³„ ê³ ìœ  ìŒì„± í• ë‹¹"""
        
        # ElevenLabs ë‹¤êµ­ì–´ ìŒì„± í™œìš©
        voice_options = {
            "male_young": ["Josh", "Adam", "Antoni", "Arnold"],
            "male_adult": ["Clyde", "Dave", "Ethan", "Fin"],
            "male_senior": ["George", "Harry", "James"],
            "female_young": ["Bella", "Charlotte", "Domi", "Elli"],
            "female_adult": ["Emily", "Freya", "Gigi", "Grace"],
            "female_senior": ["Glinda", "Jessie"]
        }
        
        # ìŒì„± ë³€ì¡° íŒŒë¼ë¯¸í„°ë¡œ ë‹¤ì–‘ì„± í™•ë³´
        base_voice = self.select_base_voice(
            character["voice_profile"]["gender"],
            character["voice_profile"]["age_group"]
        )
        
        voice_modulation = {
            "pitch": self.calculate_pitch(character),
            "speed": self.calculate_speed(character),
            "emotion_baseline": character["voice_profile"]["tone"]
        }
        
        return {
            "base_voice_id": base_voice,
            "modulation": voice_modulation,
            "backup_voice_id": self.get_backup_voice(base_voice)
        }
    
    def get_current_states(self, series_id: str) -> Dict:
        """í˜„ì¬ ìºë¦­í„°ë“¤ì˜ ìƒíƒœ ì¡°íšŒ"""
        characters = self.db.query("""
            SELECT name, current_state, emotional_state, location, 
                   active_goals, resolved_goals
            FROM character_states
            WHERE series_id = %s
        """, (series_id,))
        
        return {char["name"]: char for char in characters}
    
    def update_character_state(self, series_id: str, character_name: str, changes: Dict):
        """ì—í”¼ì†Œë“œ í›„ ìºë¦­í„° ìƒíƒœ ì—…ë°ì´íŠ¸"""
        current_state = self.get_character_state(series_id, character_name)
        
        # ìƒíƒœ ì—…ë°ì´íŠ¸
        new_state = {
            "emotional_state": changes.get("emotional_state", current_state["emotional_state"]),
            "location": changes.get("location", current_state["location"]),
            "active_goals": self.update_goals(current_state["active_goals"], changes),
            "new_traits": changes.get("new_traits", []),
            "relationships": self.update_relationships(current_state["relationships"], changes)
        }
        
        self.db.update("character_states", new_state, {
            "series_id": series_id,
            "character_name": character_name
        })
    
    def get_relationship_status(self, series_id: str) -> Dict:
        """ìºë¦­í„° ê°„ ê´€ê³„ ìƒíƒœ ì¡°íšŒ"""
        return self.db.query("""
            SELECT character1, character2, relationship_type, 
                   intimacy_level, recent_events
            FROM character_relationships
            WHERE series_id = %s
        """, (series_id,))
```

#### 4.1.4 í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ (ì—°ì†ì„± ê°•í™”)
```python
SERIES_PLOT_TEMPLATE = """
ë“œë¼ë§ˆ ì‹œë¦¬ì¦ˆ ì „ì²´ í”Œë¡¯ì„ ìƒì„±í•´ì£¼ì„¸ìš”.

ì‹œë¦¬ì¦ˆ ì •ë³´:
- ì œëª©: {title}
- ì¥ë¥´: {genre}
- ì´ íšŒì°¨: {total_episodes}
- ì£¼ìš” í…Œë§ˆ: {main_theme}
- íƒ€ê²Ÿ: {target_audience}

ìš”êµ¬ì‚¬í•­:
1. ì „ì²´ ìŠ¤í† ë¦¬ ì•„í¬ (ê¸°ìŠ¹ì „ê²°)
2. ì£¼ìš” ê°ˆë“±ê³¼ í•´ê²° ì§€ì 
3. ìºë¦­í„° ì„±ì¥ ê¶¤ì 
4. ë¡œë§¨ìŠ¤ ë°œì „ ë‹¨ê³„
5. ì„œë¸Œí”Œë¡¯ 2-3ê°œ
6. ê° ì—í”¼ì†Œë“œë³„ ì£¼ìš” ì´ë²¤íŠ¸

í˜•ì‹:
{
    "overall_arc": {
        "exposition": "1-3í™”: ì¸ë¬¼ ì†Œê°œì™€ ë°°ê²½ ì„¤ì •",
        "rising_action": "4-10í™”: ê°ˆë“± ì‹¬í™”ì™€ ê´€ê³„ ë°œì „",
        "climax": "11-13í™”: ì£¼ìš” ê°ˆë“± ì •ì ",
        "resolution": "14-16í™”: í•´ê²°ê³¼ ìƒˆë¡œìš´ ì‹œì‘"
    },
    "main_conflict": "ì„¤ëª…",
    "sub_plots": [
        {"title": "ì„œë¸Œí”Œë¡¯1", "episodes": [2, 5, 8, 12]},
        {"title": "ì„œë¸Œí”Œë¡¯2", "episodes": [3, 7, 11, 15]}
    ],
    "romance_progression": {
        "first_meeting": 1,
        "growing_interest": 3,
        "first_conflict": 5,
        "confession": 9,
        "major_crisis": 12,
        "resolution": 15
    }
}
"""

EPISODE_SCRIPT_TEMPLATE = """
ì—°ì† ë“œë¼ë§ˆ ì—í”¼ì†Œë“œ ëŒ€ë³¸ì„ ìƒì„±í•´ì£¼ì„¸ìš”.

ì‹œë¦¬ì¦ˆ ì •ë³´:
{series_info}

í˜„ì¬ ì—í”¼ì†Œë“œ: {episode_number}/{total_episodes}
ì—í”¼ì†Œë“œ ê°œìš”: {episode_outline}

ì´ì „ ì¤„ê±°ë¦¬:
{previous_events}

ë¯¸í•´ê²° í”Œë¡¯:
{unresolved_plots}

ìºë¦­í„° í˜„ì¬ ìƒíƒœ:
{character_states}

ìºë¦­í„° ê°„ ê´€ê³„:
{relationships}

ìŠ¤í† ë¦¬ ì§„í–‰ë„: {story_progress}%

ì´ë²ˆ ì—í”¼ì†Œë“œ ìš”êµ¬ì‚¬í•­:
1. ì´ì „ ì‚¬ê±´ë“¤ê³¼ ìì—°ìŠ¤ëŸ½ê²Œ ì—°ê²°
2. ìºë¦­í„° ì¼ê´€ì„± ìœ ì§€
3. ìƒˆë¡œìš´ ê°ˆë“± ìš”ì†Œ 1ê°œ ì¶”ê°€
4. ê¸°ì¡´ ê°ˆë“± ì¤‘ 1ê°œ ë¶€ë¶„ í•´ê²°
5. ë‹¤ìŒ íšŒ ì˜ˆê³ ê°€ ë  ë§Œí•œ í´ë¦¬í”„í–‰ì–´
6. 10ë¶„ ë¶„ëŸ‰ (ëŒ€ì‚¬ 80-100ê°œ)

ì£¼ì˜ì‚¬í•­:
- ê°‘ì‘ìŠ¤ëŸ¬ìš´ ì„±ê²© ë³€í™” ê¸ˆì§€
- ì´ì „ ì—í”¼ì†Œë“œì™€ ëª¨ìˆœë˜ëŠ” ë‚´ìš© ê¸ˆì§€
- ìŠí˜€ì§„ ìºë¦­í„° ì—†ì´ ëª¨ë‘ ë“±ì¥
- ê´€ê³„ ë°œì „ì€ ì ì§„ì ìœ¼ë¡œ

ì¶œë ¥ í˜•ì‹:
{
    "episode_title": "ì œëª©",
    "summary": "í•œ ì¤„ ìš”ì•½",
    "scenes": [...],
    "character_developments": {
        "ìºë¦­í„°ëª…": "ì´ë²ˆ í™” ë°œì „ì‚¬í•­"
    },
    "plot_progressions": {
        "main_plot": "ì§„ì „ ë‚´ìš©",
        "sub_plot_1": "ì§„ì „ ë‚´ìš©"
    },
    "cliffhanger": "ë‹¤ìŒ íšŒ ê¶ê¸ˆì¦ ìœ ë°œ ìš”ì†Œ"
}
"""

CONTINUITY_CHECK_TEMPLATE = """
ìƒì„±ëœ ëŒ€ë³¸ì˜ ì—°ì†ì„±ì„ ê²€ì¦í•´ì£¼ì„¸ìš”.

ì´ì „ ì—í”¼ì†Œë“œ ì •ë³´:
{previous_episodes}

í˜„ì¬ ëŒ€ë³¸:
{current_script}

ê²€ì¦ í•­ëª©:
1. ìºë¦­í„° ì¼ê´€ì„± (ì„±ê²©, ë§íˆ¬, í–‰ë™)
2. ìŠ¤í† ë¦¬ ì—°ì†ì„± (ì‚¬ê±´ì˜ ì¸ê³¼ê´€ê³„)
3. ì‹œê°„/ì¥ì†Œ ì—°ì†ì„±
4. ê´€ê³„ ë°œì „ì˜ ìì—°ìŠ¤ëŸ¬ì›€
5. ì„¤ì • ëª¨ìˆœ ì—¬ë¶€

ë¬¸ì œ ë°œê²¬ ì‹œ:
{
    "continuity_issues": [
        {
            "type": "character_inconsistency",
            "character": "ìºë¦­í„°ëª…",
            "issue": "êµ¬ì²´ì  ë¬¸ì œ",
            "suggestion": "ìˆ˜ì • ì œì•ˆ"
        }
    ],
    "severity": "high/medium/low"
}
"""

### 4.2 ìŒì„± ìƒì„± ëª¨ë“ˆ (voice_generator.py) - 10ëª… ì´ìƒ ìºë¦­í„° ì§€ì›

#### 4.2.1 í´ë˜ìŠ¤ êµ¬ì¡°
```python
class VoiceGenerator:
    def __init__(self):
        self.elevenlabs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)
        self.voice_mapping = self.load_voice_mapping()
        self.voice_cache = VoiceCache()  # ìŒì„± ì¬ì‚¬ìš©ì„ ìœ„í•œ ìºì‹œ
        self.voice_synthesizer = VoiceSynthesizer()  # ìŒì„± ë³€ì¡° ì‹œìŠ¤í…œ
    
    def generate_dialogue_voice(
        self,
        character: str,
        text: str,
        emotion: str,
        scene_context: Dict = None
    ) -> str:
        """
        ë‹¨ì¼ ëŒ€ì‚¬ ìŒì„± ìƒì„± (ë‹¤ì–‘í•œ ìºë¦­í„° ì§€ì›)
        
        Returns:
            str: ìƒì„±ëœ ìŒì„± íŒŒì¼ ê²½ë¡œ
        """
        # ìºë¦­í„° ìŒì„± í”„ë¡œí•„ ì¡°íšŒ
        voice_profile = self.get_character_voice_profile(character)
        
        # ìŒì„± ë³€ì¡° íŒŒë¼ë¯¸í„° ê³„ì‚°
        modulation_params = self.calculate_modulation(
            voice_profile,
            emotion,
            scene_context
        )
        
        # ìŒì„± ìƒì„±
        if voice_profile["type"] == "full_voice":
            # ElevenLabs ì§ì ‘ ì‚¬ìš©
            audio = self.generate_with_elevenlabs(
                text,
                voice_profile["voice_id"],
                modulation_params
            )
        else:
            # ê¸°ë³¸ ìŒì„± + ë³€ì¡°
            audio = self.generate_with_modulation(
                text,
                voice_profile["base_voice_id"],
                modulation_params
            )
        
        # í›„ì²˜ë¦¬ (ë…¸ì´ì¦ˆ ì œê±°, ìŒì§ˆ ê°œì„ )
        audio = self.post_process_audio(audio, voice_profile)
        
        return self.save_audio_file(audio, character, emotion)
    
    def generate_scene_voices(self, scene: Dict) -> List[str]:
        """ì¥ë©´ë³„ ìŒì„± ì¼ê´„ ìƒì„± (ë³‘ë ¬ ì²˜ë¦¬)"""
        from concurrent.futures import ThreadPoolExecutor
        
        voice_tasks = []
        
        # ëŒ€ì‚¬ë³„ ì‘ì—… ì¤€ë¹„
        for dialogue in scene["dialogues"]:
            task = {
                "character": dialogue["character"],
                "text": dialogue["text"],
                "emotion": dialogue["emotion"],
                "scene_context": {
                    "location": scene["location"],
                    "time": scene["time"],
                    "atmosphere": scene.get("atmosphere", "neutral")
                }
            }
            voice_tasks.append(task)
        
        # ë³‘ë ¬ ì²˜ë¦¬ë¡œ ì†ë„ ê°œì„ 
        with ThreadPoolExecutor(max_workers=5) as executor:
            futures = []
            for task in voice_tasks:
                future = executor.submit(
                    self.generate_dialogue_voice,
                    **task
                )
                futures.append(future)
            
            # ê²°ê³¼ ìˆ˜ì§‘
            voice_files = []
            for future in futures:
                try:
                    voice_file = future.result(timeout=30)
                    voice_files.append(voice_file)
                except Exception as e:
                    logger.error(f"Voice generation failed: {e}")
                    # ì‹¤íŒ¨ ì‹œ TTS ë°±ì—… ì‚¬ìš©
                    voice_files.append(self.generate_backup_voice(task))
        
        return voice_files
    
    def calculate_modulation(self, voice_profile: Dict, emotion: str, context: Dict) -> Dict:
        """ìŒì„± ë³€ì¡° íŒŒë¼ë¯¸í„° ê³„ì‚°"""
        modulation = {
            "pitch": voice_profile["base_pitch"],
            "speed": voice_profile["base_speed"],
            "volume": 1.0,
            "emotion_strength": 0.5
        }
        
        # ê°ì •ë³„ ì¡°ì •
        emotion_adjustments = {
            "happy": {"pitch": +0.1, "speed": +0.05, "volume": +0.1},
            "sad": {"pitch": -0.1, "speed": -0.1, "volume": -0.1},
            "angry": {"pitch": -0.05, "speed": +0.1, "volume": +0.2},
            "surprised": {"pitch": +0.2, "speed": +0.15, "volume": +0.15},
            "fear": {"pitch": +0.15, "speed": +0.2, "volume": -0.05},
            "neutral": {"pitch": 0, "speed": 0, "volume": 0}
        }
        
        if emotion in emotion_adjustments:
            for param, adjustment in emotion_adjustments[emotion].items():
                modulation[param] += adjustment
        
        # ìƒí™©ë³„ ì¡°ì •
        if context:
            if context.get("atmosphere") == "tense":
                modulation["speed"] += 0.1
                modulation["volume"] -= 0.1
            elif context.get("atmosphere") == "romantic":
                modulation["speed"] -= 0.05
                modulation["emotion_strength"] += 0.2
        
        return modulation
    
    def generate_backup_voice(self, task: Dict) -> str:
        """ë°±ì—… TTS ì‹œìŠ¤í…œ (ElevenLabs ì‹¤íŒ¨ ì‹œ)"""
        # Google Cloud TTS ë˜ëŠ” Azure TTS ì‚¬ìš©
        from google.cloud import texttospeech
        
        client = texttospeech.TextToSpeechClient()
        
        # í•œêµ­ì–´ ìŒì„± ì„ íƒ
        voice = texttospeech.VoiceSelectionParams(
            language_code="ko-KR",
            name=self.get_google_voice_name(task["character"]),
            ssml_gender=self.get_gender_from_character(task["character"])
        )
        
        # ìŒì„± í•©ì„±
        audio_config = texttospeech.AudioConfig(
            audio_encoding=texttospeech.AudioEncoding.MP3,
            speaking_rate=self.calculate_speaking_rate(task["emotion"]),
            pitch=self.calculate_pitch_semitones(task["emotion"])
        )
        
        synthesis_input = texttospeech.SynthesisInput(text=task["text"])
        
        response = client.synthesize_speech(
            input=synthesis_input,
            voice=voice,
            audio_config=audio_config
        )
        
        return self.save_backup_audio(response.audio_content, task)
```

#### 4.2.2 ìŒì„± í”„ë¡œí•„ ê´€ë¦¬ (10ëª… ì´ìƒ)
```python
class VoiceProfileManager:
    """ë‹¤ìˆ˜ ìºë¦­í„° ìŒì„± í”„ë¡œí•„ ê´€ë¦¬"""
    
    def __init__(self):
        self.profiles = {}
        self.voice_pool = self.initialize_voice_pool()
    
    def initialize_voice_pool(self) -> Dict:
        """ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë“  ìŒì„± ë¦¬ì†ŒìŠ¤ ì´ˆê¸°í™”"""
        return {
            "elevenlabs": {
                "premium_voices": 6,  # ìœ ë£Œ ìŒì„± ìˆ˜
                "basic_voices": 4,    # ê¸°ë³¸ ìŒì„± ìˆ˜
                "voice_ids": [
                    # ë‚¨ì„± ìŒì„±
                    "21m00Tcm4TlvDq8ikWAM",  # Josh
                    "VR6AewLTigWG4xSOukaG",  # Arnold
                    "pNInz6obpgDQGcFmaJgB",  # Adam
                    "yoZ06aMxZJJ28mfd3POQ",  # Sam
                    # ì—¬ì„± ìŒì„±
                    "AZnzlk1XvdvUeBnXmlld",  # Domi
                    "EXAVITQu4vr4xnSDxMaL",  # Bella
                    "MF3mGyEYCl7XYWbV9V6O",  # Elli
                    "XrExE9yKIg1WjnnlVkGX",  # Charlotte
                ]
            },
            "google_tts": {
                "korean_voices": [
                    "ko-KR-Wavenet-A",  # ì—¬ì„±
                    "ko-KR-Wavenet-B",  # ì—¬ì„±  
                    "ko-KR-Wavenet-C",  # ë‚¨ì„±
                    "ko-KR-Wavenet-D",  # ë‚¨ì„±
                ]
            },
            "azure_tts": {
                "korean_voices": [
                    "ko-KR-InJoonNeural",    # ë‚¨ì„±
                    "ko-KR-BongJinNeural",   # ë‚¨ì„±
                    "ko-KR-SunHiNeural",     # ì—¬ì„±
                    "ko-KR-JiMinNeural",     # ì—¬ì„±
                ]
            }
        }
    
    def create_character_voice_profile(self, character: Dict) -> Dict:
        """ìºë¦­í„°ë³„ ê³ ìœ  ìŒì„± í”„ë¡œí•„ ìƒì„±"""
        
        importance = character.get("importance", "minor")
        
        if importance == "main":
            # ì£¼ì¸ê³µ: ì „ìš© ElevenLabs ìŒì„±
            return self.create_premium_voice_profile(character)
        elif importance == "major_supporting":
            # ì£¼ìš” ì¡°ì—°: ElevenLabs ë˜ëŠ” ê³ í’ˆì§ˆ TTS
            return self.create_major_voice_profile(character)
        else:
            # ê¸°íƒ€: TTS + ë³€ì¡°
            return self.create_minor_voice_profile(character)
    
    def create_premium_voice_profile(self, character: Dict) -> Dict:
        """ì£¼ì¸ê³µìš© í”„ë¦¬ë¯¸ì—„ ìŒì„± í”„ë¡œí•„"""
        # ì‚¬ìš© ê°€ëŠ¥í•œ ìŒì„± ì¤‘ ìµœì  ì„ íƒ
        assigned_voice = self.select_best_voice(
            character["voice_profile"],
            self.voice_pool["elevenlabs"]["voice_ids"]
        )
        
        return {
            "type": "full_voice",
            "service": "elevenlabs",
            "voice_id": assigned_voice,
            "base_pitch": 0,
            "base_speed": 1.0,
            "quality": "premium",
            "consistency_check": True
        }
    
    def create_minor_voice_profile(self, character: Dict) -> Dict:
        """ì¡°ì—°ìš© TTS ê¸°ë°˜ ìŒì„± í”„ë¡œí•„"""
        # ê¸°ë³¸ ìŒì„± + ê³ ìœ  ë³€ì¡°ê°’
        base_voice = self.select_tts_voice(character["voice_profile"])
        
        # ìºë¦­í„°ë³„ ê³ ìœ  ë³€ì¡°ê°’ ìƒì„± (ì¤‘ë³µ ë°©ì§€)
        unique_modulation = self.generate_unique_modulation(
            character["id"],
            character["voice_profile"]
        )
        
        return {
            "type": "modulated_voice",
            "service": "google_tts",
            "base_voice_id": base_voice,
            "base_pitch": unique_modulation["pitch"],
            "base_speed": unique_modulation["speed"],
            "timbre_shift": unique_modulation["timbre"],
            "quality": "standard"
        }
    
    def generate_unique_modulation(self, character_id: str, voice_profile: Dict) -> Dict:
        """ìºë¦­í„°ë³„ ê³ ìœ í•œ ìŒì„± ë³€ì¡°ê°’ ìƒì„±"""
        import hashlib
        
        # ìºë¦­í„° IDë¥¼ ì‹œë“œë¡œ ì‚¬ìš©í•˜ì—¬ ì¼ê´€ëœ ë³€ì¡°ê°’ ìƒì„±
        seed = int(hashlib.md5(character_id.encode()).hexdigest()[:8], 16)
        
        # ê²°ì •ë¡ ì  ëœë¤ê°’ ìƒì„±
        import random
        random.seed(seed)
        
        age_factor = {
            "young": (-0.1, 0.1),
            "young_adult": (-0.05, 0.05),
            "adult": (-0.02, 0.08),
            "middle_age": (0, 0.1),
            "senior": (0.05, 0.15)
        }
        
        pitch_range = age_factor.get(voice_profile["age_group"], (0, 0))
        
        return {
            "pitch": random.uniform(*pitch_range),
            "speed": random.uniform(0.9, 1.1),
            "timbre": random.uniform(-0.2, 0.2)
        }

### 4.3 ì•„ë°”íƒ€ ì˜ìƒ ìƒì„± ëª¨ë“ˆ (avatar_generator.py) - ë‹¤ìˆ˜ ìºë¦­í„° ì²˜ë¦¬

#### 4.3.1 í´ë˜ìŠ¤ êµ¬ì¡°
```python
class AvatarGenerator:
    def __init__(self):
        self.heygen_client = HeyGenAPI(api_key=HEYGEN_API_KEY)
        self.avatar_mapping = self.load_avatar_mapping()
        self.scene_composer = SceneComposer()  # ë‹¤ì¤‘ ìºë¦­í„° ì¥ë©´ êµ¬ì„±
        self.avatar_strategy_manager = AvatarStrategyManager()
    
    def create_avatar_video(
        self,
        character: str,
        audio_url: str,
        background: str,
        duration: float,
        scene_type: str = "single"
    ) -> str:
        """
        ì•„ë°”íƒ€ ì˜ìƒ ìƒì„± (ìºë¦­í„° ì¤‘ìš”ë„ë³„ ì „ëµ)
        
        Returns:
            str: ìƒì„±ëœ ì˜ìƒ URL
        """
        character_data = self.get_character_data(character)
        strategy = self.avatar_strategy_manager.get_strategy(character_data)
        
        if strategy["type"] == "full_avatar":
            return self.create_full_avatar_video(
                character_data,
                audio_url,
                background,
                duration
            )
        elif strategy["type"] == "partial_avatar":
            return self.create_partial_avatar_video(
                character_data,
                audio_url,
                background,
                duration,
                strategy["view_angle"]
            )
        else:  # voice_only
            return self.create_voice_only_video(
                character_data,
                audio_url,
                background,
                duration
            )
    
    def generate_scene_videos(self, scene: Dict, audio_files: List[str]) -> List[str]:
        """ì¥ë©´ë³„ ì˜ìƒ ìƒì„± (ë‹¤ì¤‘ ìºë¦­í„° ëŒ€í™” ì²˜ë¦¬)"""
        
        # ì¥ë©´ ë¶„ì„
        scene_analysis = self.analyze_scene_composition(scene)
        
        if scene_analysis["type"] == "dialogue":
            # ëŒ€í™” ì¥ë©´: ìºë¦­í„° êµì°¨ í¸ì§‘
            return self.create_dialogue_scene(scene, audio_files)
        elif scene_analysis["type"] == "group":
            # ê·¸ë£¹ ì¥ë©´: í•©ì„± ë˜ëŠ” ë¶„í•  í™”ë©´
            return self.create_group_scene(scene, audio_files)
        else:
            # ë‹¨ë… ì¥ë©´
            return self.create_single_scenes(scene, audio_files)
    
    def create_dialogue_scene(self, scene: Dict, audio_files: List[str]) -> List[str]:
        """ëŒ€í™” ì¥ë©´ ìƒì„± (shot-reverse-shot)"""
        videos = []
        
        for idx, dialogue in enumerate(scene["dialogues"]):
            character = dialogue["character"]
            audio_file = audio_files[idx]
            
            # í™”ì ì˜ìƒ
            speaker_video = self.create_avatar_video(
                character=character,
                audio_url=audio_file,
                background=scene["location"],
                duration=dialogue["duration"],
                scene_type="speaker"
            )
            
            # ì²­ì ë°˜ì‘ ì˜ìƒ (í•„ìš”ì‹œ)
            if idx < len(scene["dialogues"]) - 1:
                next_character = scene["dialogues"][idx + 1]["character"]
                if next_character != character:
                    listener_video = self.create_reaction_video(
                        character=next_character,
                        emotion=dialogue.get("listener_reaction", "neutral"),
                        duration=min(dialogue["duration"] * 0.3, 2.0),
                        background=scene["location"]
                    )
                    videos.append({"type": "intercut", "videos": [speaker_video, listener_video]})
                else:
                    videos.append({"type": "single", "video": speaker_video})
            else:
                videos.append({"type": "single", "video": speaker_video})
        
        return videos
    
    def create_voice_only_video(
        self,
        character_data: Dict,
        audio_url: str,
        background: str,
        duration: float
    ) -> str:
        """ìŒì„±ë§Œ ìˆëŠ” ì˜ìƒ ìƒì„± (ì¡°ì—°ìš©)"""
        
        # ì „ëµ 1: ë°°ê²½ + ìë§‰
        # ì „ëµ 2: ì‹¤ë£¨ì—£
        # ì „ëµ 3: ëŒ€í™” ìƒí™© í‘œí˜„ (ì˜ˆ: ì „í™” í†µí™” ì¥ë©´)
        
        video_style = self.select_voice_only_style(character_data, background)
        
        if video_style == "subtitle_overlay":
            return self.create_subtitle_video(audio_url, background, duration)
        elif video_style == "silhouette":
            return self.create_silhouette_video(character_data, audio_url, background, duration)
        else:
            return self.create_context_video(character_data, audio_url, background, duration)

class AvatarStrategyManager:
    """ìºë¦­í„°ë³„ ì•„ë°”íƒ€ ì „ëµ ê´€ë¦¬"""
    
    def __init__(self):
        self.strategies = self.load_strategies()
        self.avatar_usage_tracker = AvatarUsageTracker()
    
    def get_strategy(self, character_data: Dict) -> Dict:
        """ìºë¦­í„°ì— ìµœì í™”ëœ ì•„ë°”íƒ€ ì „ëµ ë°˜í™˜"""
        
        importance = character_data.get("importance", "minor")
        episode_appearance = character_data.get("episode_appearance_rate", 0.1)
        
        # ì•„ë°”íƒ€ ì‚¬ìš©ëŸ‰ ì²´í¬ (API í•œë„ ê´€ë¦¬)
        current_usage = self.avatar_usage_tracker.get_current_usage()
        
        if importance == "main":
            return {
                "type": "full_avatar",
                "avatar_id": character_data["avatar_assignment"]["avatar_id"],
                "quality": "high",
                "lip_sync": True
            }
        elif importance == "major_supporting" and current_usage < 0.7:
            # API ì‚¬ìš©ëŸ‰ ì—¬ìœ  ìˆì„ ë•Œë§Œ ì•„ë°”íƒ€ ì‚¬ìš©
            return {
                "type": "partial_avatar",
                "view_angle": self.select_view_angle(character_data),
                "quality": "medium",
                "lip_sync": False
            }
        else:
            return {
                "type": "voice_only",
                "visual_style": "contextual"
            }
    
    def select_view_angle(self, character_data: Dict) -> str:
        """ë¶€ë¶„ ì•„ë°”íƒ€ìš© ì•µê¸€ ì„ íƒ"""
        # ìºë¦­í„° íŠ¹ì„±ì— ë”°ë¼ ì ì ˆí•œ ì•µê¸€ ì„ íƒ
        if character_data.get("mysterious", False):
            return "silhouette"
        elif character_data.get("role") == "phone_call":
            return "voice_over"
        else:
            return "side_profile"
```

#### 4.3.2 ë‹¤ì¤‘ ìºë¦­í„° ì¥ë©´ ì²˜ë¦¬
```python
class SceneComposer:
    """ë³µì¡í•œ ë‹¤ì¤‘ ìºë¦­í„° ì¥ë©´ êµ¬ì„±"""
    
    def compose_group_scene(self, characters: List[str], scene_data: Dict) -> Dict:
        """ê·¸ë£¹ ì¥ë©´ êµ¬ì„± (3ëª… ì´ìƒ)"""
        
        composition_strategies = {
            "meeting": self.compose_meeting_scene,
            "party": self.compose_party_scene,
            "family_dinner": self.compose_dinner_scene,
            "office": self.compose_office_scene
        }
        
        scene_type = self.detect_scene_type(scene_data)
        composer = composition_strategies.get(scene_type, self.compose_generic_group)
        
        return composer(characters, scene_data)
    
    def compose_meeting_scene(self, characters: List[str], scene_data: Dict) -> Dict:
        """íšŒì˜ ì¥ë©´ êµ¬ì„±"""
        # ì£¼ìš” í™”ì ì¤‘ì‹¬ + ë‚˜ë¨¸ì§€ëŠ” reaction shots
        main_speakers = self.identify_main_speakers(scene_data["dialogues"])
        
        return {
            "layout": "focus_on_speaker",
            "main_characters": main_speakers[:2],  # ì•„ë°”íƒ€ ì‚¬ìš©
            "supporting_characters": {
                char: "voice_with_subtitle" for char in characters 
                if char not in main_speakers[:2]
            },
            "camera_work": "dynamic_focus",
            "background": "meeting_room"
        }
    
    def handle_avatar_limitations(self, required_avatars: int, available_avatars: int) -> Dict:
        """ì•„ë°”íƒ€ ë¶€ì¡± ì‹œ ëŒ€ì²´ ì „ëµ"""
        
        if required_avatars <= available_avatars:
            return {"strategy": "all_avatars"}
        
        # ìš°ì„ ìˆœìœ„ ê¸°ë°˜ í• ë‹¹
        priority_assignment = {
            "strategy": "priority_based",
            "avatar_slots": available_avatars,
            "alternatives": {
                "voice_over_image": required_avatars - available_avatars,
                "techniques": [
                    "over_shoulder_shot",
                    "point_of_view_shot",
                    "reaction_cutaway",
                    "establishing_shot_with_dialogue"
                ]
            }
        }
        
        return priority_assignment

### 4.4 ì˜ìƒ í¸ì§‘ ëª¨ë“ˆ (video_editor.py)

#### 4.4.1 í´ë˜ìŠ¤ êµ¬ì¡°
```python
class VideoEditor:
    def __init__(self):
        self.intro_template = "templates/intro.mp4"
        self.outro_template = "templates/outro.mp4"
    
    def edit_episode(
        self,
        episode_data: Dict,
        video_files: List[str]
    ) -> str:
        """
        ì—í”¼ì†Œë“œ ì „ì²´ í¸ì§‘
        
        Returns:
            str: ìµœì¢… ì˜ìƒ íŒŒì¼ ê²½ë¡œ
        """
        pass
    
    def add_subtitles(self, video_clip, dialogue_data: Dict):
        """ìë§‰ ì¶”ê°€"""
        pass
    
    def add_transitions(self, clips: List):
        """ì¥ë©´ ì „í™˜ íš¨ê³¼ ì¶”ê°€"""
        pass
    
    def add_background_music(self, video_clip, bgm_file: str):
        """ë°°ê²½ìŒì•… ì¶”ê°€"""
        pass
```

#### 4.4.2 í¸ì§‘ ì„¤ì •
```python
EDIT_SETTINGS = {
    "video": {
        "resolution": (1920, 1080),
        "fps": 30,
        "codec": "libx264",
        "bitrate": "5000k"
    },
    "subtitles": {
        "font": "NanumGothic",
        "size": 48,
        "color": "white",
        "stroke_color": "black",
        "stroke_width": 2,
        "position": ("center", "bottom")
    },
    "transitions": {
        "fade": {"duration": 0.5},
        "slide": {"duration": 0.3},
        "zoom": {"duration": 0.4}
    }
}
```

### 4.5 YouTube ì—…ë¡œë“œ ëª¨ë“ˆ (youtube_uploader.py)

#### 4.5.1 í´ë˜ìŠ¤ êµ¬ì¡°
```python
class YouTubeUploader:
    def __init__(self):
        self.youtube_client = self.authenticate_youtube()
        self.upload_config = self.load_upload_config()
    
    def upload_video(
        self,
        video_file: str,
        episode_data: Dict
    ) -> str:
        """
        YouTube ì˜ìƒ ì—…ë¡œë“œ
        
        Returns:
            str: ì—…ë¡œë“œëœ ì˜ìƒ ID
        """
        pass
    
    def generate_metadata(self, episode_data: Dict) -> Dict:
        """ì˜ìƒ ë©”íƒ€ë°ì´í„° ìƒì„±"""
        pass
    
    def create_thumbnail(self, episode_data: Dict) -> str:
        """ì¸ë„¤ì¼ ìë™ ìƒì„±"""
        pass
    
    def schedule_publish(self, video_id: str, publish_time: datetime):
        """ì˜ˆì•½ ê²Œì‹œ ì„¤ì •"""
        pass
```

#### 4.5.2 ì—…ë¡œë“œ ì„¤ì •
```python
UPLOAD_CONFIG = {
    "title_template": "{drama_title} EP.{episode_number} - {episode_title}",
    "description_template": """
{drama_title} {episode_number}í™” - {episode_title}

ğŸ“º AIê°€ ë§Œë“  ìƒˆë¡œìš´ í˜•íƒœì˜ ì›¹ë“œë¼ë§ˆ
ğŸ­ ì¶œì—°: AI ì•„ë°”íƒ€
âœï¸ ê°ë³¸: AI (GPT-4)
ğŸµ ìŒì„±: AI (ElevenLabs)

[ì¤„ê±°ë¦¬]
{episode_summary}

[ë‹¤ìŒ ì´ì•¼ê¸°]
ë§¤ì¼ ì €ë… 7ì‹œ ì—…ë¡œë“œ!

#AIë“œë¼ë§ˆ #ì›¹ë“œë¼ë§ˆ #{genre}
    """,
    "tags": [
        "AIë“œë¼ë§ˆ", "ì›¹ë“œë¼ë§ˆ", "AI", "ì¸ê³µì§€ëŠ¥",
        "AIContent", "WebDrama", "KDrama"
    ],
    "category_id": "24",  # Entertainment
    "privacy_status": "private",
    "made_for_kids": False
}
```

---

## 5. ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

### 5.1 í…Œì´ë¸” ì •ì˜
```sql
-- ë“œë¼ë§ˆ ì‹œë¦¬ì¦ˆ
CREATE TABLE drama_series (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    genre VARCHAR(50),
    description TEXT,
    total_episodes INTEGER DEFAULT 100,
    status VARCHAR(20) DEFAULT 'active',
    series_plot JSONB,  -- ì „ì²´ ì‹œë¦¬ì¦ˆ í”Œë¡¯
    story_arc JSONB,    -- ìŠ¤í† ë¦¬ ì•„í¬ ì •ë³´
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ì—í”¼ì†Œë“œ
CREATE TABLE episodes (
    id SERIAL PRIMARY KEY,
    series_id INTEGER REFERENCES drama_series(id),
    episode_number INTEGER NOT NULL,
    title VARCHAR(200),
    script JSONB,
    summary TEXT,
    key_events JSONB,              -- ì£¼ìš” ì‚¬ê±´ë“¤
    character_developments JSONB,   -- ìºë¦­í„° ë°œì „ì‚¬í•­
    relationship_changes JSONB,     -- ê´€ê³„ ë³€í™”
    unresolved_plots JSONB,        -- ë¯¸í•´ê²° í”Œë¡¯
    cliffhanger TEXT,              -- ë‹¤ìŒíšŒ ì˜ˆê³ 
    status VARCHAR(20) DEFAULT 'pending',
    youtube_id VARCHAR(50),
    youtube_url VARCHAR(500),
    view_count INTEGER DEFAULT 0,
    like_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    published_at TIMESTAMP,
    UNIQUE(series_id, episode_number)
);

-- ìºë¦­í„°
CREATE TABLE characters (
    id SERIAL PRIMARY KEY,
    series_id INTEGER REFERENCES drama_series(id),
    name VARCHAR(100) NOT NULL,
    role VARCHAR(50),
    age INTEGER,
    occupation VARCHAR(100),
    personality JSONB,
    background TEXT,
    goals JSONB,
    secrets JSONB,
    avatar_id VARCHAR(100),
    voice_id VARCHAR(100),
    profile JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(series_id, name)
);

-- ìºë¦­í„° ìƒíƒœ ì¶”ì 
CREATE TABLE character_states (
    id SERIAL PRIMARY KEY,
    series_id INTEGER REFERENCES drama_series(id),
    episode_id INTEGER REFERENCES episodes(id),
    character_name VARCHAR(100),
    emotional_state VARCHAR(50),
    location VARCHAR(100),
    active_goals JSONB,
    resolved_goals JSONB,
    new_traits JSONB,
    current_situation TEXT,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (series_id, character_name) REFERENCES characters(series_id, name)
);

-- ìºë¦­í„° ê´€ê³„
CREATE TABLE character_relationships (
    id SERIAL PRIMARY KEY,
    series_id INTEGER REFERENCES drama_series(id),
    episode_id INTEGER REFERENCES episodes(id),
    character1 VARCHAR(100),
    character2 VARCHAR(100),
    relationship_type VARCHAR(50),  -- ì¹œêµ¬, ì—°ì¸, ë¼ì´ë²Œ ë“±
    intimacy_level INTEGER,         -- 1-10
    recent_events JSONB,
    status VARCHAR(50),             -- ë°œì „ì¤‘, ê°ˆë“±ì¤‘, í™”í•´ ë“±
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ìŠ¤í† ë¦¬ ë©”ëª¨ë¦¬
CREATE TABLE story_memory (
    id SERIAL PRIMARY KEY,
    series_id INTEGER REFERENCES drama_series(id),
    episode_number INTEGER,
    memory_type VARCHAR(50),        -- plot_point, character_event, relationship_event
    content JSONB,
    importance_level INTEGER,       -- 1-5
    referenced_episodes JSONB,      -- ì´ ê¸°ì–µì´ ì°¸ì¡°ëœ ì—í”¼ì†Œë“œë“¤
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ì—í”¼ì†Œë“œ ì•„ì›ƒë¼ì¸
CREATE TABLE episode_outlines (
    id SERIAL PRIMARY KEY,
    series_id INTEGER REFERENCES drama_series(id),
    episode_number INTEGER,
    main_event TEXT,
    sub_events JSONB,
    character_focus VARCHAR(100),   -- ì´ë²ˆ í™” ì¤‘ì‹¬ ìºë¦­í„°
    plot_progression JSONB,
    target_emotions JSONB,          -- ì‹œì²­ìê°€ ëŠë¼ê¸¸ ì›í•˜ëŠ” ê°ì •
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(series_id, episode_number)
);

-- ì‘ì—… í
CREATE TABLE jobs (
    id SERIAL PRIMARY KEY,
    episode_id INTEGER REFERENCES episodes(id),
    job_type VARCHAR(50) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    priority INTEGER DEFAULT 5,
    payload JSONB,
    result JSONB,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ì‘ì—… ë¡œê·¸
CREATE TABLE job_logs (
    id SERIAL PRIMARY KEY,
    job_id INTEGER REFERENCES jobs(id),
    level VARCHAR(20),
    message TEXT,
    details JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- API ì‚¬ìš© ë¡œê·¸
CREATE TABLE api_usage (
    id SERIAL PRIMARY KEY,
    api_name VARCHAR(50),
    endpoint VARCHAR(200),
    request_data JSONB,
    response_data JSONB,
    cost DECIMAL(10, 4),
    duration_ms INTEGER,
    status_code INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

---

## 6. API ì—”ë“œí¬ì¸íŠ¸ ì •ì˜

### 6.1 RESTful API
```yaml
# ë“œë¼ë§ˆ ê´€ë¦¬
POST   /api/v1/dramas                    # ìƒˆ ë“œë¼ë§ˆ ìƒì„±
GET    /api/v1/dramas                    # ë“œë¼ë§ˆ ëª©ë¡
GET    /api/v1/dramas/{drama_id}         # ë“œë¼ë§ˆ ìƒì„¸
PUT    /api/v1/dramas/{drama_id}         # ë“œë¼ë§ˆ ìˆ˜ì •
DELETE /api/v1/dramas/{drama_id}         # ë“œë¼ë§ˆ ì‚­ì œ

# ì—í”¼ì†Œë“œ ê´€ë¦¬
POST   /api/v1/dramas/{drama_id}/episodes           # ì—í”¼ì†Œë“œ ìƒì„±
GET    /api/v1/dramas/{drama_id}/episodes           # ì—í”¼ì†Œë“œ ëª©ë¡
GET    /api/v1/episodes/{episode_id}                # ì—í”¼ì†Œë“œ ìƒì„¸
PUT    /api/v1/episodes/{episode_id}                # ì—í”¼ì†Œë“œ ìˆ˜ì •
DELETE /api/v1/episodes/{episode_id}                # ì—í”¼ì†Œë“œ ì‚­ì œ
POST   /api/v1/episodes/{episode_id}/regenerate     # ì¬ìƒì„±

# ì‘ì—… ê´€ë¦¬
POST   /api/v1/jobs                      # ì‘ì—… ìƒì„±
GET    /api/v1/jobs                      # ì‘ì—… ëª©ë¡
GET    /api/v1/jobs/{job_id}             # ì‘ì—… ìƒì„¸
POST   /api/v1/jobs/{job_id}/retry       # ì‘ì—… ì¬ì‹œë„
POST   /api/v1/jobs/{job_id}/cancel      # ì‘ì—… ì·¨ì†Œ

# í†µê³„
GET    /api/v1/stats/overview            # ì „ì²´ í†µê³„
GET    /api/v1/stats/youtube             # YouTube í†µê³„
GET    /api/v1/stats/costs               # ë¹„ìš© í†µê³„
GET    /api/v1/stats/performance         # ì„±ëŠ¥ í†µê³„

# ì‹œìŠ¤í…œ
GET    /api/v1/system/health             # í—¬ìŠ¤ì²´í¬
GET    /api/v1/system/status             # ì‹œìŠ¤í…œ ìƒíƒœ
POST   /api/v1/system/maintenance        # ìœ ì§€ë³´ìˆ˜ ëª¨ë“œ
```

### 6.2 WebSocket
```yaml
# ì‹¤ì‹œê°„ ìƒíƒœ ì—…ë°ì´íŠ¸
WS /ws/status                            # ì‹œìŠ¤í…œ ìƒíƒœ ìŠ¤íŠ¸ë¦¼
WS /ws/jobs/{job_id}                     # ì‘ì—… ì§„í–‰ ìƒíƒœ
WS /ws/logs                              # ì‹¤ì‹œê°„ ë¡œê·¸
```

---

## 7. ì‘ì—… íë¦„ (Workflow) - ê°•í™”ëœ ì‹œìŠ¤í…œ

### 7.0 ë“œë¼ë§ˆ ì‹œì‘ ì „ í•„ìˆ˜ ê²€ì¦ - ì™„ì „ ìë™í™” ë³´ì¥
```python
class DramaSeriesValidator:
    """ë“œë¼ë§ˆ ì‹œë¦¬ì¦ˆ ì‹œì‘ ì „ ì™„ì „ì„± ê²€ì¦"""
    
    def validate_before_production(self, series_config: Dict) -> ValidationResult:
        """ì œì‘ ì‹œì‘ ì „ ëª¨ë“  ìš”ì†Œ ê²€ì¦"""
        
        validations = []
        
        # 1. ìºë¦­í„° ì™„ì„±ë„ í™•ì¸ (ìµœì†Œ 10ëª…)
        if len(series_config["characters"]) < 10:
            validations.append({
                "error": "insufficient_characters",
                "message": f"ìµœì†Œ 10ëª… í•„ìš” (í˜„ì¬: {len(series_config['characters'])}ëª…)",
                "severity": "critical"
            })
        
        # 2. ìŒì„±/ì•„ë°”íƒ€ í• ë‹¹ í™•ì¸
        voice_check = self.validate_voice_assignments(series_config["characters"])
        if not voice_check["valid"]:
            validations.append({
                "error": "voice_assignment_incomplete",
                "details": voice_check["issues"],
                "severity": "critical"
            })
        
        # 3. ì „ì²´ ìŠ¤í† ë¦¬ ì•„í¬ ì™„ì„±ë„
        story_check = self.validate_story_completeness(
            series_config["story_arc"],
            series_config["total_episodes"]
        )
        if not story_check["valid"]:
            validations.append({
                "error": "incomplete_story_arc",
                "details": story_check["missing_elements"],
                "severity": "critical"
            })
        
        # 4. ì—í”¼ì†Œë“œë³„ ì•„ì›ƒë¼ì¸ ì¡´ì¬ ì—¬ë¶€
        if len(series_config.get("episode_outlines", [])) < series_config["total_episodes"]:
            validations.append({
                "error": "missing_episode_outlines",
                "message": "ëª¨ë“  ì—í”¼ì†Œë“œì˜ ì•„ì›ƒë¼ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤",
                "severity": "critical"
            })
        
        # 5. API ë¦¬ì†ŒìŠ¤ ê°€ìš©ì„±
        resource_check = self.check_api_resources(series_config)
        if not resource_check["sufficient"]:
            validations.append({
                "error": "insufficient_api_resources",
                "details": resource_check["shortages"],
                "severity": "warning"
            })
        
        # 6. ìë™í™” ì‹œìŠ¤í…œ ì²´í¬
        automation_check = self.validate_automation_readiness()
        if not automation_check["ready"]:
            validations.append({
                "error": "automation_not_ready",
                "details": automation_check["issues"],
                "severity": "critical"
            })
        
        return ValidationResult(
            is_valid=len([v for v in validations if v["severity"] == "critical"]) == 0,
            errors=validations,
            can_proceed=len(validations) == 0
        )
    
    def validate_automation_readiness(self) -> Dict:
        """ì™„ì „ ìë™í™” ì¤€ë¹„ ìƒíƒœ í™•ì¸"""
        checks = {
            "scheduler": self.check_scheduler_status(),
            "error_recovery": self.check_error_recovery_system(),
            "monitoring": self.check_monitoring_system(),
            "backup_systems": self.check_backup_systems(),
            "api_keys": self.check_all_api_keys(),
            "storage": self.check_storage_capacity()
        }
        
        return {
            "ready": all(checks.values()),
            "issues": [k for k, v in checks.items() if not v]
        }

class PreProductionSetup:
    """ì œì‘ ì „ í•„ìˆ˜ ì„¤ì • ìë™í™”"""
    
    def setup_complete_series(self, initial_config: Dict) -> Dict:
        """
        ì´ˆê¸° ì„¤ì •ë§Œìœ¼ë¡œ ì „ì²´ ì‹œë¦¬ì¦ˆ ì¤€ë¹„
        
        Args:
            initial_config: {
                "title": "ë“œë¼ë§ˆ ì œëª©",
                "genre": "romance",
                "total_episodes": 16,
                "basic_premise": "ê¸°ë³¸ ì¤„ê±°ë¦¬"
            }
        """
        
        # 1. ì „ì²´ ìŠ¤í† ë¦¬ ì•„í¬ ìƒì„±
        story_arc = self.generate_complete_story_arc(initial_config)
        
        # 2. ëª¨ë“  ìºë¦­í„° ìë™ ìƒì„± (ìµœì†Œ 10ëª… ë³´ì¥)
        characters = self.generate_all_characters(initial_config, story_arc)
        
        # 3. ëª¨ë“  ì—í”¼ì†Œë“œ ì•„ì›ƒë¼ì¸ ìƒì„±
        episode_outlines = self.generate_all_episode_outlines(
            story_arc,
            characters,
            initial_config["total_episodes"]
        )
        
        # 4. ìºë¦­í„°ë³„ ìŒì„±/ì•„ë°”íƒ€ ìë™ í• ë‹¹
        character_assignments = self.assign_voices_and_avatars(characters)
        
        # 5. ê´€ê³„ë„ ë° ê°ˆë“± êµ¬ì¡° ìƒì„±
        relationships = self.create_relationship_matrix(characters)
        conflicts = self.design_conflict_structure(characters, story_arc)
        
        # 6. í’ˆì§ˆ ì²´í¬ í…œí”Œë¦¿ ìƒì„±
        quality_templates = self.create_quality_check_templates(initial_config["genre"])
        
        # 7. ë¹„ìƒ ê³„íš ìˆ˜ë¦½
        contingency_plans = self.create_contingency_plans(initial_config)
        
        # ì™„ì„±ëœ ì‹œë¦¬ì¦ˆ ì„¤ì •
        complete_series = {
            "series_id": generate_uuid(),
            "initial_config": initial_config,
            "story_arc": story_arc,
            "characters": characters,
            "character_assignments": character_assignments,
            "episode_outlines": episode_outlines,
            "relationships": relationships,
            "conflicts": conflicts,
            "quality_templates": quality_templates,
            "contingency_plans": contingency_plans,
            "production_ready": True
        }
        
        # ìµœì¢… ê²€ì¦
        validation = DramaSeriesValidator().validate_before_production(complete_series)
        
        if validation.is_valid:
            return complete_series
        else:
            # ìë™ ìˆ˜ì • ì‹œë„
            return self.auto_fix_issues(complete_series, validation.errors)

### 7.1 ì¥ë¥´ë³„ íŠ¹í™” ì‹œìŠ¤í…œ
```python
class GenreSpecificTemplates:
    """ì¥ë¥´ë³„ ë“œë¼ë§ˆ ì œì‘ í…œí”Œë¦¿"""
    
    TEMPLATES = {
        "romance": {
            "structure": {
                "act1": "ë§Œë‚¨ê³¼ ëŒë¦¼ (20%)",
                "act2": "ê´€ê³„ ë°œì „ê³¼ ê°ˆë“± (60%)",
                "act3": "ìœ„ê¸°ì™€ í•´ê²° (20%)"
            },
            "required_elements": [
                "first_meeting",
                "growing_attraction",
                "first_conflict",
                "confession",
                "major_crisis",
                "resolution"
            ],
            "pacing": {
                "confession_timing": 0.5,  # ì „ì²´ì˜ 50% ì§€ì 
                "crisis_timing": 0.8       # ì „ì²´ì˜ 80% ì§€ì 
            },
            "min_characters": 4,
            "character_roles": ["ì£¼ì¸ê³µ", "ìƒëŒ€ì—­", "ì¡°ë ¥ì", "ë°©í•´ì"]
        },
        
        "thriller": {
            "structure": {
                "act1": "ì‚¬ê±´ ë°œìƒê³¼ ìˆ˜ìˆ˜ê»˜ë¼ (25%)",
                "act2": "ì¶”ì ê³¼ ë‹¨ì„œ ìˆ˜ì§‘ (50%)",
                "act3": "ë°˜ì „ê³¼ í•´ê²° (25%)"
            },
            "required_elements": [
                "inciting_incident",
                "red_herrings",
                "clue_revelations",
                "false_climax",
                "true_villain_reveal",
                "resolution"
            ],
            "pacing": {
                "first_clue": 0.2,
                "major_revelation": 0.7,
                "final_twist": 0.9
            },
            "min_characters": 6,
            "character_roles": ["ì£¼ì¸ê³µ", "ì¡°ë ¥ì", "ìš©ì˜ìë“¤", "ì§„ë²”", "í¬ìƒì"]
        },
        
        "comedy": {
            "structure": {
                "act1": "ìºë¦­í„° ì†Œê°œì™€ ìƒí™© ì„¤ì • (30%)",
                "act2": "ì˜¤í•´ì™€ ì†Œë™ (50%)",
                "act3": "í•´ê²°ê³¼ êµí›ˆ (20%)"
            },
            "required_elements": [
                "character_quirks",
                "misunderstandings",
                "running_gags",
                "slapstick_moments",
                "heartwarming_resolution"
            ],
            "comedy_beats_per_episode": 10,
            "min_characters": 5
        }
    }
    
    def get_genre_prompt(self, genre: str, episode_context: Dict) -> str:
        """ì¥ë¥´ë³„ íŠ¹í™”ëœ í”„ë¡¬í”„íŠ¸ ìƒì„±"""
        template = self.TEMPLATES[genre]
        
        # í˜„ì¬ ì§„í–‰ë„ì— ë”°ë¥¸ ìš”ì†Œ ê°•ì¡°
        progress = episode_context["episode_number"] / episode_context["total_episodes"]
        
        required_elements = self.get_required_elements_for_progress(
            genre, progress, template["required_elements"]
        )
        
        return self.build_genre_specific_prompt(genre, required_elements, episode_context)
```

### 7.2 í’ˆì§ˆ ê´€ë¦¬ ì‹œìŠ¤í…œ
```python
class QualityAssuranceSystem:
    """AI ìƒì„± ì½˜í…ì¸  í’ˆì§ˆ ê´€ë¦¬"""
    
    def __init__(self):
        self.quality_checkers = [
            DialogueNaturalnessChecker(),
            PlotCoherenceChecker(),
            CharacterConsistencyChecker(),
            PacingChecker(),
            EmotionalArcChecker()
        ]
        self.quality_threshold = 0.8
    
    def assess_script_quality(self, script: Dict, context: Dict) -> QualityReport:
        """ëŒ€ë³¸ í’ˆì§ˆ ì¢…í•© í‰ê°€"""
        
        scores = {}
        issues = []
        
        for checker in self.quality_checkers:
            result = checker.check(script, context)
            scores[checker.name] = result.score
            if result.score < self.quality_threshold:
                issues.extend(result.issues)
        
        overall_score = sum(scores.values()) / len(scores)
        
        return QualityReport(
            overall_score=overall_score,
            category_scores=scores,
            issues=issues,
            needs_regeneration=overall_score < self.quality_threshold
        )
    
    def auto_improve_script(self, script: Dict, quality_report: QualityReport) -> Dict:
        """í’ˆì§ˆ ì´ìŠˆ ìë™ ê°œì„ """
        
        improved_script = script.copy()
        
        for issue in quality_report.issues:
            if issue["type"] == "unnatural_dialogue":
                improved_script = self.improve_dialogue(
                    improved_script, 
                    issue["character"],
                    issue["scene"]
                )
            elif issue["type"] == "pacing_issue":
                improved_script = self.adjust_pacing(
                    improved_script,
                    issue["scene_range"]
                )
            elif issue["type"] == "character_inconsistency":
                improved_script = self.fix_character_consistency(
                    improved_script,
                    issue["character"],
                    issue["context"]
                )
        
        return improved_script

class DialogueNaturalnessChecker:
    """ëŒ€ì‚¬ ìì—°ìŠ¤ëŸ¬ì›€ ê²€ì‚¬"""
    
    def check(self, script: Dict, context: Dict) -> CheckResult:
        issues = []
        total_dialogues = 0
        natural_dialogues = 0
        
        for scene in script["scenes"]:
            for dialogue in scene["dialogues"]:
                total_dialogues += 1
                
                # ìì—°ìŠ¤ëŸ¬ì›€ ê²€ì‚¬
                if self.is_natural_korean(dialogue["text"]):
                    natural_dialogues += 1
                else:
                    issues.append({
                        "type": "unnatural_dialogue",
                        "character": dialogue["character"],
                        "scene": scene["scene_number"],
                        "text": dialogue["text"],
                        "suggestion": self.suggest_improvement(dialogue["text"])
                    })
        
        score = natural_dialogues / total_dialogues if total_dialogues > 0 else 0
        
        return CheckResult(
            score=score,
            issues=issues
        )
    
    def is_natural_korean(self, text: str) -> bool:
        """í•œêµ­ì–´ ëŒ€ì‚¬ ìì—°ìŠ¤ëŸ¬ì›€ íŒë‹¨"""
        # ë¶€ìì—°ìŠ¤ëŸ¬ìš´ íŒ¨í„´ ì²´í¬
        unnatural_patterns = [
            r"ë‚˜ëŠ”.*ì…ë‹ˆë‹¤",  # ì¼ìƒ ëŒ€í™”ì—ì„œ ì–´ìƒ‰í•œ í‘œí˜„
            r"ë‹¹ì‹ ì€.*ì…ë‹ˆê¹Œ",  # ë„ˆë¬´ ê²©ì‹ì 
            r"ê·¸ê²ƒì€.*ê²ƒì…ë‹ˆë‹¤"  # ë²ˆì—­íˆ¬
        ]
        
        for pattern in unnatural_patterns:
            if re.search(pattern, text):
                return False
        
        return True
```

### 7.3 ì•„ë°”íƒ€/ìŒì„± ì¼ê´€ì„± ì‹œìŠ¤í…œ
```python
class AvatarVoiceConsistencyManager:
    """ìºë¦­í„°ë³„ ì•„ë°”íƒ€/ìŒì„± ì¼ê´€ì„± ê´€ë¦¬"""
    
    def __init__(self):
        self.avatar_pool = self.load_avatar_pool()
        self.voice_pool = self.load_voice_pool()
        self.character_assignments = {}
    
    def assign_avatar_voice_to_characters(self, characters: List[Dict]) -> Dict:
        """ìºë¦­í„°ë³„ ìµœì  ì•„ë°”íƒ€/ìŒì„± í• ë‹¹"""
        
        assignments = {}
        
        for character in characters:
            # 1. ìºë¦­í„° íŠ¹ì„± ë¶„ì„
            char_features = self.analyze_character_features(character)
            
            # 2. ìµœì  ì•„ë°”íƒ€ ì„ íƒ
            best_avatar = self.find_best_matching_avatar(
                char_features,
                already_used=[a["avatar_id"] for a in assignments.values()]
            )
            
            # 3. ìµœì  ìŒì„± ì„ íƒ
            best_voice = self.find_best_matching_voice(
                char_features,
                already_used=[a["voice_id"] for a in assignments.values()]
            )
            
            # 4. ë°±ì—… ì˜µì…˜ ì¤€ë¹„
            backup_avatars = self.get_similar_avatars(best_avatar, count=3)
            backup_voices = self.get_similar_voices(best_voice, count=3)
            
            assignments[character["name"]] = {
                "avatar_id": best_avatar,
                "voice_id": best_voice,
                "backup_avatars": backup_avatars,
                "backup_voices": backup_voices,
                "locked": True  # ì‹œë¦¬ì¦ˆ ì¤‘ê°„ì— ë³€ê²½ ë°©ì§€
            }
        
        self.character_assignments = assignments
        return assignments
    
    def ensure_consistency(self, series_id: str, episode_num: int) -> bool:
        """ì—í”¼ì†Œë“œë³„ ì¼ê´€ì„± í™•ì¸"""
        
        # ì´ì „ ì—í”¼ì†Œë“œì™€ ë™ì¼í•œ ì•„ë°”íƒ€/ìŒì„± ì‚¬ìš© í™•ì¸
        previous_assignments = self.get_previous_assignments(series_id, episode_num - 1)
        current_assignments = self.character_assignments
        
        for char_name in current_assignments:
            if char_name in previous_assignments:
                if (current_assignments[char_name]["avatar_id"] != 
                    previous_assignments[char_name]["avatar_id"]):
                    # ë¶ˆì¼ì¹˜ ë°œê²¬ - ìë™ ìˆ˜ì •
                    self.fix_inconsistency(char_name, previous_assignments[char_name])
        
        return True
```

### 7.4 ì™„ì „ ìë™í™” ì›Œí¬í”Œë¡œìš° - 100% ë¬´ì¸ ìš´ì˜
```python
@celery_app.task
def fully_automated_production():
    """
    100% ìë™í™”ëœ ì¼ì¼ ì œì‘ í”„ë¡œì„¸ìŠ¤
    ì‚¬ëŒì˜ ê°œì… ì—†ì´ ì™„ì „ ìë™ ìš´ì˜
    """
    try:
        # 1. í™œì„± ì‹œë¦¬ì¦ˆ ì¡°íšŒ
        active_series = get_active_series()
        
        for series in active_series:
            # 2. ì˜¤ëŠ˜ ì œì‘í•  ì—í”¼ì†Œë“œ ìë™ ê²°ì •
            episodes_to_produce = calculate_daily_episodes(series)
            
            # 3. ê° ì—í”¼ì†Œë“œ ì™„ì „ ìë™ ì œì‘
            for ep_num in episodes_to_produce:
                produce_episode_fully_automated.delay(
                    series.id,
                    ep_num,
                    retry_policy={
                        'max_retries': 5,
                        'retry_backoff': True,
                        'retry_jitter': True
                    }
                )
        
        # 4. ì‹œìŠ¤í…œ ìƒíƒœ ìë™ ëª¨ë‹ˆí„°ë§
        monitor_system_health.delay()
        
    except Exception as e:
        # ì¤‘ëŒ€ ì˜¤ë¥˜ ì‹œ ìë™ ë³µêµ¬
        handle_critical_error(e)
        # ë°±ì—… ì‹œìŠ¤í…œ í™œì„±í™”
        activate_backup_production.delay()

@celery_app.task(bind=True)
def produce_episode_fully_automated(self, series_id: int, episode_number: int):
    """
    ì—í”¼ì†Œë“œ ì™„ì „ ìë™ ì œì‘ (ì¸ê°„ ê°œì… ë¶ˆí•„ìš”)
    """
    episode_id = f"{series_id}_EP{episode_number}"
    
    try:
        # 1. ì œì‘ ì‹œì‘ ì „ ì‚¬ì „ ì²´í¬
        pre_check = automated_pre_production_check(series_id, episode_number)
        if not pre_check["ready"]:
            auto_fix_issues(pre_check["issues"])
        
        # 2. ëŒ€ë³¸ ìë™ ìƒì„± (ì—°ì†ì„± ë³´ì¥)
        script_result = generate_script_with_full_continuity(series_id, episode_number)
        
        # 3. í’ˆì§ˆ ìë™ ê²€ì¦ ë° ê°œì„ 
        quality_result = auto_quality_check_and_improve(script_result)
        
        # 4. ìŒì„± ìë™ ìƒì„± (10ëª… ì´ìƒ ìºë¦­í„°)
        voice_result = generate_all_character_voices(quality_result["script"])
        
        # 5. ì˜ìƒ ìë™ ìƒì„± (ìŠ¤ë§ˆíŠ¸ ì•„ë°”íƒ€ í• ë‹¹)
        video_result = generate_videos_with_smart_allocation(
            quality_result["script"],
            voice_result["files"]
        )
        
        # 6. ìë™ í¸ì§‘ (ì¥ë©´ ì „í™˜, ìë§‰, BGM)
        edited_result = auto_edit_episode(video_result["videos"])
        
        # 7. ìµœì¢… í’ˆì§ˆ ê²€ì¦
        final_check = final_quality_validation(edited_result)
        
        # 8. YouTube ìë™ ì—…ë¡œë“œ ë° ì˜ˆì•½
        upload_result = auto_upload_to_youtube(
            final_check["video"],
            episode_metadata=auto_generate_metadata(series_id, episode_number)
        )
        
        # 9. ì œì‘ ì™„ë£Œ ë° ë‹¤ìŒ ì—í”¼ì†Œë“œ ì¤€ë¹„
        finalize_and_prepare_next(series_id, episode_number)
        
        return {
            "status": "success",
            "episode_id": episode_id,
            "youtube_id": upload_result["video_id"],
            "production_time": calculate_production_time()
        }
        
    except Exception as e:
        # ìë™ ì—ëŸ¬ ì²˜ë¦¬ ë° ë³µêµ¬
        return handle_episode_error_automatically(
            series_id,
            episode_number,
            e,
            self.request.retries
        )

class AutomatedQualitySystem:
    """ì™„ì „ ìë™í™”ëœ í’ˆì§ˆ ê´€ë¦¬ ì‹œìŠ¤í…œ"""
    
    def auto_quality_check_and_improve(self, script: Dict) -> Dict:
        """í’ˆì§ˆ ìë™ ê²€ì‚¬ ë° ê°œì„ """
        
        max_iterations = 3
        current_script = script
        
        for iteration in range(max_iterations):
            # 1. í’ˆì§ˆ ì ìˆ˜ ê³„ì‚°
            quality_score = self.calculate_quality_score(current_script)
            
            if quality_score["overall"] >= 0.85:
                return {
                    "script": current_script,
                    "quality_score": quality_score,
                    "iterations": iteration + 1
                }
            
            # 2. ìë™ ê°œì„ 
            improvements = self.identify_improvements(current_script, quality_score)
            current_script = self.apply_improvements(current_script, improvements)
        
        # ìµœëŒ€ ë°˜ë³µ í›„ì—ë„ í’ˆì§ˆ ë¯¸ë‹¬ ì‹œ
        return self.fallback_quality_assurance(current_script)
    
    def calculate_quality_score(self, script: Dict) -> Dict:
        """ë‹¤ì°¨ì› í’ˆì§ˆ ì ìˆ˜ ê³„ì‚°"""
        scores = {
            "dialogue_naturalness": self.check_dialogue_naturalness(script),
            "plot_coherence": self.check_plot_coherence(script),
            "character_consistency": self.check_character_consistency(script),
            "pacing": self.check_pacing(script),
            "emotional_arc": self.check_emotional_arc(script),
            "continuity": self.check_continuity(script)
        }
        
        scores["overall"] = sum(scores.values()) / len(scores)
        return scores

class SmartResourceAllocation:
    """ë¦¬ì†ŒìŠ¤ ìë™ í• ë‹¹ ì‹œìŠ¤í…œ"""
    
    def allocate_avatars_intelligently(self, scene: Dict, available_resources: Dict) -> Dict:
        """
        ì¥ë©´ë³„ ìµœì  ì•„ë°”íƒ€ í• ë‹¹
        - ì¤‘ìš”ë„ ê¸°ë°˜
        - ë¦¬ì†ŒìŠ¤ ì œì•½ ê³ ë ¤
        - ì‹œê°ì  ë‹¤ì–‘ì„± í™•ë³´
        """
        
        # 1. ì¥ë©´ ë¶„ì„
        scene_importance = self.calculate_scene_importance(scene)
        character_importance = self.calculate_character_importance_in_scene(scene)
        
        # 2. í• ë‹¹ ì „ëµ ê²°ì •
        if scene_importance > 0.8:
            # ì¤‘ìš” ì¥ë©´: ìµœëŒ€í•œ ì•„ë°”íƒ€ ì‚¬ìš©
            strategy = "maximize_avatars"
        elif available_resources["avatar_credits"] < 50:
            # ë¦¬ì†ŒìŠ¤ ë¶€ì¡±: ì ˆì•½ ëª¨ë“œ
            strategy = "conserve_resources"
        else:
            # ì¼ë°˜: ê· í˜• í• ë‹¹
            strategy = "balanced"
        
        # 3. êµ¬ì²´ì  í• ë‹¹
        allocations = {}
        
        for character in scene["characters"]:
            if strategy == "maximize_avatars":
                allocations[character] = self.allocate_best_avatar(character)
            elif strategy == "conserve_resources":
                allocations[character] = self.allocate_minimal_resources(character)
            else:
                allocations[character] = self.allocate_balanced(character, character_importance[character])
        
        return allocations

class AutoErrorRecovery:
    """ìë™ ì—ëŸ¬ ë³µêµ¬ ì‹œìŠ¤í…œ"""
    
    def handle_episode_error_automatically(
        self,
        series_id: int,
        episode_number: int,
        error: Exception,
        retry_count: int
    ) -> Dict:
        """ì—ëŸ¬ ìë™ ì²˜ë¦¬ ë° ë³µêµ¬"""
        
        error_type = self.classify_error(error)
        
        recovery_strategies = {
            "api_timeout": self.handle_api_timeout,
            "api_quota": self.handle_api_quota_exceeded,
            "quality_fail": self.handle_quality_failure,
            "resource_limit": self.handle_resource_limit,
            "unknown": self.handle_unknown_error
        }
        
        # ì ì ˆí•œ ë³µêµ¬ ì „ëµ ì‹¤í–‰
        recovery_func = recovery_strategies.get(error_type, self.handle_unknown_error)
        recovery_result = recovery_func(series_id, episode_number, error, retry_count)
        
        if recovery_result["success"]:
            # ë³µêµ¬ ì„±ê³µ - ì œì‘ ì¬ê°œ
            return self.resume_production(
                series_id,
                episode_number,
                recovery_result["checkpoint"]
            )
        else:
            # ë³µêµ¬ ì‹¤íŒ¨ - ëŒ€ì²´ ì „ëµ
            return self.execute_fallback_strategy(series_id, episode_number)
    
    def handle_api_quota_exceeded(self, series_id: int, episode_number: int, error: Exception, retry_count: int) -> Dict:
        """API í• ë‹¹ëŸ‰ ì´ˆê³¼ ìë™ ì²˜ë¦¬"""
        
        # 1. ëŒ€ì²´ API ê³„ì •ìœ¼ë¡œ ì „í™˜
        if self.switch_to_backup_api():
            return {"success": True, "checkpoint": "api_switched"}
        
        # 2. ë¦¬ì†ŒìŠ¤ ì ˆì•½ ëª¨ë“œë¡œ ì „í™˜
        if self.enable_resource_saving_mode():
            return {"success": True, "checkpoint": "resource_saving"}
        
        # 3. ë‹¤ìŒ ë‚ ë¡œ ì¼ì • ìë™ ì¡°ì •
        if retry_count < 3:
            self.reschedule_episode(series_id, episode_number, hours=24)
            return {"success": True, "checkpoint": "rescheduled"}
        
        return {"success": False}voices_generated"]:
                voices = self.generate_voices_with_partial_recovery(script)
                self.checkpoint_manager.save_voices(series_id, episode_num, voices)
                checkpoints["voices_generated"] = True
            else:
                voices = self.checkpoint_manager.load_voices(series_id, episode_num)
            
            # 3. ì˜ìƒ ìƒì„± (ì”¬ë³„ ê°œë³„ ì²˜ë¦¬)
            if not checkpoints["videos_generated"]:
                videos = self.generate_videos_by_scene(script, voices)
                checkpoints["videos_generated"] = True
            
            # ... ë‚˜ë¨¸ì§€ ë‹¨ê³„ë„ ë™ì¼í•˜ê²Œ ì²˜ë¦¬
            
        except Exception as e:
            # ì‹¤íŒ¨ ì§€ì ë¶€í„° ì¬ì‹œì‘ ê°€ëŠ¥
            self.handle_production_failure(series_id, episode_num, checkpoints, e)
            raise
    
    def generate_voices_with_partial_recovery(self, script: Dict) -> Dict:
        """ë¶€ë¶„ ì‹¤íŒ¨ ë³µêµ¬ê°€ ê°€ëŠ¥í•œ ìŒì„± ìƒì„±"""
        
        voices = {}
        failed_dialogues = []
        
        for scene in script["scenes"]:
            for dialogue in scene["dialogues"]:
                dialogue_id = f"s{scene['scene_number']}_d{dialogue['id']}"
                
                try:
                    # ê°œë³„ ëŒ€ì‚¬ ìŒì„± ìƒì„±
                    voice_file = self.generate_single_voice(dialogue)
                    voices[dialogue_id] = voice_file
                    
                except Exception as e:
                    logger.error(f"Voice generation failed for {dialogue_id}: {e}")
                    failed_dialogues.append(dialogue_id)
        
        # ì‹¤íŒ¨í•œ ëŒ€ì‚¬ë§Œ ì¬ì‹œë„
        if failed_dialogues:
            voices.update(self.retry_failed_voices(script, failed_dialogues))
        
        return voices
```

### 7.5 ì‹œì²­ì í”¼ë“œë°± ë°˜ì˜ ì‹œìŠ¤í…œ
```python
class ViewerFeedbackSystem:
    """ì‹œì²­ì ë°˜ì‘ ë¶„ì„ ë° ë°˜ì˜"""
    
    def __init__(self):
        self.youtube_analyzer = YouTubeCommentAnalyzer()
        self.sentiment_analyzer = SentimentAnalyzer()
    
    def analyze_episode_feedback(self, youtube_id: str) -> FeedbackReport:
        """ì—í”¼ì†Œë“œë³„ ì‹œì²­ì ë°˜ì‘ ë¶„ì„"""
        
        # 1. ëŒ“ê¸€ ìˆ˜ì§‘
        comments = self.youtube_analyzer.get_comments(youtube_id, limit=1000)
        
        # 2. ê°ì • ë¶„ì„
        sentiment_analysis = self.sentiment_analyzer.analyze_comments(comments)
        
        # 3. ì£¼ìš” í‚¤ì›Œë“œ ì¶”ì¶œ
        keywords = self.extract_keywords(comments)
        
        # 4. ìºë¦­í„°ë³„ ë°˜ì‘ ë¶„ì„
        character_feedback = self.analyze_character_popularity(comments)
        
        # 5. ìŠ¤í† ë¦¬ ìš”ì†Œë³„ ë°˜ì‘
        story_feedback = self.analyze_story_elements(comments)
        
        return FeedbackReport(
            overall_sentiment=sentiment_analysis["overall"],
            character_popularity=character_feedback,
            loved_elements=story_feedback["positive"],
            disliked_elements=story_feedback["negative"],
            viewer_suggestions=self.extract_suggestions(comments)
        )
    
    def adapt_future_episodes(self, series_id: str, feedback_reports: List[FeedbackReport]):
        """í”¼ë“œë°±ì„ ë°”íƒ•ìœ¼ë¡œ í–¥í›„ ì—í”¼ì†Œë“œ ì¡°ì •"""
        
        adaptations = {
            "character_focus": self.calculate_character_focus_changes(feedback_reports),
            "pacing_adjustments": self.calculate_pacing_changes(feedback_reports),
            "plot_emphasis": self.calculate_plot_emphasis(feedback_reports),
            "tone_adjustments": self.calculate_tone_adjustments(feedback_reports)
        }
        
        # í–¥í›„ ì—í”¼ì†Œë“œ ì•„ì›ƒë¼ì¸ ìˆ˜ì •
        self.update_future_outlines(series_id, adaptations)
        
        return adaptations

class AutomatedStoryAdjustment:
    """ì‹œì²­ì ë°˜ì‘ì— ë”°ë¥¸ ìë™ ìŠ¤í† ë¦¬ ì¡°ì •"""
    
    def adjust_character_screen_time(self, series_id: str, popularity_data: Dict):
        """ì¸ê¸° ìºë¦­í„° ì¶œì—° ë¹„ì¤‘ ìë™ ì¡°ì •"""
        
        # 1. ì¸ê¸°ë„ ìˆœìœ„ ê³„ì‚°
        character_ranking = sorted(
            popularity_data.items(),
            key=lambda x: x[1]["score"],
            reverse=True
        )
        
        # 2. í–¥í›„ ì—í”¼ì†Œë“œ ì¶œì—° ë¹„ì¤‘ ì¬ë¶„ë°°
        future_episodes = self.get_unproduced_episodes(series_id)
        
        for episode in future_episodes:
            # ì¸ê¸° ìºë¦­í„° ì¤‘ì‹¬ìœ¼ë¡œ ì¬êµ¬ì„±
            adjusted_outline = self.redistribute_character_focus(
                episode["outline"],
                character_ranking
            )
            
            self.update_episode_outline(series_id, episode["number"], adjusted_outline)
```

### 7.6 ì™„ì „ ìë™í™” ê²€ì¦ ì²´í¬ë¦¬ìŠ¤íŠ¸
```python
class ProductionReadinessChecker:
    """ì œì‘ ì‹œì‘ ì „ ì™„ì „ ìë™í™” ê°€ëŠ¥ì„± ê²€ì¦"""
    
    def comprehensive_check(self, series_config: Dict) -> ReadinessReport:
        """ì¢…í•©ì ì¸ ì œì‘ ì¤€ë¹„ë„ ê²€ì‚¬"""
        
        checks = {
            # 1. ìŠ¤í† ë¦¬ ì™„ì„±ë„
            "story_completeness": self.check_story_completeness(series_config),
            
            # 2. ìºë¦­í„° ì¤€ë¹„ë„
            "character_readiness": self.check_character_readiness(series_config),
            
            # 3. ê¸°ìˆ ì  ì¤€ë¹„ë„
            "technical_readiness": self.check_technical_readiness(),
            
            # 4. ë¦¬ì†ŒìŠ¤ ê°€ìš©ì„±
            "resource_availability": self.check_resource_availability(series_config),
            
            # 5. ì¥ë¥´ë³„ ìš”êµ¬ì‚¬í•­
            "genre_requirements": self.check_genre_requirements(series_config),
            
            # 6. ì—°ì†ì„± ì‹œìŠ¤í…œ
            "continuity_system": self.check_continuity_system(),
            
            # 7. í’ˆì§ˆ ë³´ì¦ ì‹œìŠ¤í…œ
            "quality_assurance": self.check_quality_system(),
            
            # 8. ë³µêµ¬ ì‹œìŠ¤í…œ
            "recovery_system": self.check_recovery_system(),
            
            # 9. í™•ì¥ì„±
            "scalability": self.check_scalability(series_config["total_episodes"])
        }
        
        all_ready = all(check["passed"] for check in checks.values())
        
        return ReadinessReport(
            ready_to_start=all_ready,
            checks=checks,
            estimated_success_rate=self.calculate_success_rate(checks),
            recommendations=self.generate_recommendations(checks)
        )
```

### 7.1 ì‹œë¦¬ì¦ˆ ì œì‘ ì›Œí¬í”Œë¡œìš°
```python
@celery_app.task
def create_new_drama_series(series_config: Dict):
    """
    ìƒˆë¡œìš´ ë“œë¼ë§ˆ ì‹œë¦¬ì¦ˆ ì‹œì‘
    """
    # 1. ì‹œë¦¬ì¦ˆ ê¸°íš
    series_generator = SeriesGenerator()
    series_data = series_generator.create_series_blueprint(series_config)
    
    # 2. ì „ì²´ ìŠ¤í† ë¦¬ ì•„í¬ ìƒì„±
    story_arc = series_generator.generate_story_arc(
        title=series_config["title"],
        genre=series_config["genre"],
        episodes=series_config["total_episodes"]
    )
    
    # 3. ìºë¦­í„° ìƒì„± ë° ê´€ê³„ ì„¤ì •
    characters = series_generator.create_all_characters(series_config)
    relationships = series_generator.establish_relationships(characters)
    
    # 4. ì—í”¼ì†Œë“œë³„ ì•„ì›ƒë¼ì¸ ìƒì„±
    episode_outlines = series_generator.create_episode_outlines(
        story_arc,
        characters,
        series_config["total_episodes"]
    )
    
    # 5. ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥
    series_id = save_series_data(series_data, characters, episode_outlines)
    
    # 6. ì²« ë²ˆì§¸ ì—í”¼ì†Œë“œ ì œì‘ ì‹œì‘
    start_episode_production.delay(series_id, 1)
    
    return series_id

@celery_app.task
def daily_series_production():
    """
    ì§„í–‰ ì¤‘ì¸ ì‹œë¦¬ì¦ˆë“¤ì˜ ì¼ì¼ ì œì‘
    """
    # 1. í™œì„± ì‹œë¦¬ì¦ˆ ì¡°íšŒ
    active_series = get_active_series()
    
    for series in active_series:
        # 2. ë‹¤ìŒ ì œì‘í•  ì—í”¼ì†Œë“œ í™•ì¸
        next_episodes = get_next_episodes_to_produce(
            series.id,
            count=series.daily_episode_count
        )
        
        # 3. ê° ì—í”¼ì†Œë“œ ì œì‘
        for episode_num in next_episodes:
            # ì—°ì†ì„± ì²´í¬
            if check_continuity_ready(series.id, episode_num):
                produce_episode_with_continuity.delay(
                    series.id,
                    episode_num
                )
            else:
                logger.warning(f"Continuity not ready for {series.id} ep{episode_num}")

@celery_app.task
def produce_episode_with_continuity(series_id: int, episode_number: int):
    """
    ì—°ì†ì„±ì„ ê³ ë ¤í•œ ì—í”¼ì†Œë“œ ì œì‘
    """
    try:
        # 1. ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ
        context_builder = ContextBuilder()
        episode_context = context_builder.build_full_context(series_id, episode_number)
        
        # 2. ëŒ€ë³¸ ìƒì„± (ì—°ì†ì„± ë°˜ì˜)
        script_generator = ScriptGenerator()
        script = script_generator.generate_episode_script(
            series_id=series_id,
            episode_number=episode_number,
            context=episode_context
        )
        
        # 3. ì—°ì†ì„± ê²€ì¦
        continuity_checker = ContinuityChecker()
        validation_result = continuity_checker.validate(script, episode_context)
        
        if not validation_result.is_valid:
            # ë¬¸ì œ ë°œê²¬ ì‹œ ì¬ìƒì„±
            script = script_generator.regenerate_with_fixes(
                script,
                validation_result.issues
            )
        
        # 4. ìºë¦­í„° ìƒíƒœ ì—…ë°ì´íŠ¸
        update_character_states(series_id, episode_number, script)
        
        # 5. ìŠ¤í† ë¦¬ ë©”ëª¨ë¦¬ ì—…ë°ì´íŠ¸
        update_story_memory(series_id, episode_number, script)
        
        # 6. ìŒì„±, ì˜ìƒ, í¸ì§‘, ì—…ë¡œë“œ ì§„í–‰
        chain = (
            generate_voices_for_episode.s(script) |
            generate_videos_for_episode.s() |
            edit_episode_with_continuity.s() |
            upload_episode.s() |
            finalize_episode.s()
        )
        
        chain.apply_async()
        
    except Exception as e:
        handle_episode_error(series_id, episode_number, e)
```

### 7.2 ì—°ì†ì„± ê´€ë¦¬ ì‹œìŠ¤í…œ
```python
class ContinuityChecker:
    """ì—í”¼ì†Œë“œ ê°„ ì—°ì†ì„±ì„ ê²€ì¦í•˜ëŠ” ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.validators = [
            CharacterConsistencyValidator(),
            PlotContinuityValidator(),
            RelationshipProgressionValidator(),
            TimelineValidator(),
            SettingConsistencyValidator()
        ]
    
    def validate(self, script: Dict, context: Dict) -> ValidationResult:
        """ì¢…í•©ì ì¸ ì—°ì†ì„± ê²€ì¦"""
        issues = []
        
        for validator in self.validators:
            validation = validator.validate(script, context)
            if not validation.passed:
                issues.extend(validation.issues)
        
        return ValidationResult(
            is_valid=len(issues) == 0,
            issues=issues
        )

class CharacterConsistencyValidator:
    """ìºë¦­í„° ì¼ê´€ì„± ê²€ì¦"""
    
    def validate(self, script: Dict, context: Dict) -> ValidationResult:
        issues = []
        
        # 1. ìºë¦­í„° ì„±ê²© ì¼ê´€ì„± ì²´í¬
        for scene in script["scenes"]:
            for dialogue in scene["dialogues"]:
                character = dialogue["character"]
                if not self.check_personality_consistency(
                    character,
                    dialogue["text"],
                    context["character_states"][character]
                ):
                    issues.append({
                        "type": "personality_inconsistency",
                        "character": character,
                        "scene": scene["scene_number"],
                        "issue": "ìºë¦­í„° ì„±ê²©ê³¼ ë§ì§€ ì•ŠëŠ” ëŒ€ì‚¬"
                    })
        
        # 2. ìºë¦­í„° ì§€ì‹ ì¼ê´€ì„± ì²´í¬
        # (ì´ì „ì— ëª¨ë¥´ë˜ ì •ë³´ë¥¼ ê°‘ìê¸° ì•„ëŠ” ê²½ìš° ë“±)
        
        # 3. ìºë¦­í„° ëª©í‘œ ì¼ê´€ì„± ì²´í¬
        # (ê°‘ì‘ìŠ¤ëŸ¬ìš´ ëª©í‘œ ë³€ê²½ ë“±)
        
        return ValidationResult(len(issues) == 0, issues)

class PlotContinuityValidator:
    """í”Œë¡¯ ì—°ì†ì„± ê²€ì¦"""
    
    def validate(self, script: Dict, context: Dict) -> ValidationResult:
        issues = []
        
        # 1. ë¯¸í•´ê²° í”Œë¡¯ ì²˜ë¦¬ í™•ì¸
        unresolved = context["unresolved_plots"]
        addressed = self.find_addressed_plots(script, unresolved)
        
        # 2. ìƒˆë¡œìš´ í”Œë¡¯ê³¼ ê¸°ì¡´ í”Œë¡¯ ì¶©ëŒ í™•ì¸
        new_plots = self.extract_new_plots(script)
        conflicts = self.check_plot_conflicts(new_plots, context["overall_plot"])
        
        # 3. ì¸ê³¼ê´€ê³„ ê²€ì¦
        causality_issues = self.check_causality(script, context["previous_events"])
        
        issues.extend(conflicts + causality_issues)
        
        return ValidationResult(len(issues) == 0, issues)
```

### 7.3 ì‹œë¦¬ì¦ˆ ê¸°íš ë„êµ¬
```python
class SeriesGenerator:
    """ë“œë¼ë§ˆ ì‹œë¦¬ì¦ˆ ì „ì²´ ê¸°íš ìƒì„±"""
    
    def create_series_blueprint(self, config: Dict) -> Dict:
        """ì‹œë¦¬ì¦ˆ ì „ì²´ ì²­ì‚¬ì§„ ìƒì„±"""
        blueprint = {
            "title": config["title"],
            "genre": config["genre"],
            "logline": self.generate_logline(config),
            "themes": self.identify_themes(config),
            "tone": self.determine_tone(config),
            "target_audience": config["target_audience"],
            "unique_selling_points": self.generate_usps(config)
        }
        
        return blueprint
    
    def generate_story_arc(self, title: str, genre: str, episodes: int) -> Dict:
        """ì „ì²´ ìŠ¤í† ë¦¬ ì•„í¬ ìƒì„±"""
        prompt = SERIES_PLOT_TEMPLATE.format(
            title=title,
            genre=genre,
            total_episodes=episodes,
            main_theme=self.extract_main_theme(title, genre),
            target_audience=self.identify_target_audience(genre)
        )
        
        response = self.openai_client.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.8
        )
        
        story_arc = json.loads(response.choices[0].message.content)
        
        # ìŠ¤í† ë¦¬ ì•„í¬ ê²€ì¦ ë° ë³´ì™„
        story_arc = self.validate_and_enhance_arc(story_arc, episodes)
        
        return story_arc
    
    def create_episode_outlines(self, story_arc: Dict, characters: List, 
                               total_episodes: int) -> List[Dict]:
        """ê° ì—í”¼ì†Œë“œë³„ ìƒì„¸ ì•„ì›ƒë¼ì¸ ìƒì„±"""
        outlines = []
        
        # ìŠ¤í† ë¦¬ ì•„í¬ë¥¼ ì—í”¼ì†Œë“œë³„ë¡œ ë¶„ë°°
        arc_distribution = self.distribute_story_arc(story_arc, total_episodes)
        
        for ep_num in range(1, total_episodes + 1):
            outline = {
                "episode_number": ep_num,
                "arc_phase": self.get_arc_phase(ep_num, total_episodes),
                "main_event": arc_distribution[ep_num]["main_event"],
                "sub_events": arc_distribution[ep_num]["sub_events"],
                "character_focus": self.assign_character_focus(ep_num, characters),
                "emotional_journey": self.plan_emotional_journey(ep_num, story_arc),
                "cliffhanger_type": self.determine_cliffhanger(ep_num, total_episodes)
            }
            
            outlines.append(outline)
        
        return outlines
    
    def create_all_characters(self, series_config: Dict) -> List[Dict]:
        """ì‹œë¦¬ì¦ˆì˜ ëª¨ë“  ìºë¦­í„° ìƒì„±"""
        characters = []
        
        # 1. ì£¼ì¸ê³µ ìƒì„±
        protagonists = self.create_protagonists(series_config)
        characters.extend(protagonists)
        
        # 2. ì£¼ìš” ì¡°ì—° ìƒì„±
        supporting = self.create_supporting_characters(series_config, protagonists)
        characters.extend(supporting)
        
        # 3. ë°˜ë³µ ì¶œì—° ìºë¦­í„° ìƒì„±
        recurring = self.create_recurring_characters(series_config)
        characters.extend(recurring)
        
        # 4. ìºë¦­í„° ê°„ ì¼€ë¯¸ìŠ¤íŠ¸ë¦¬ ì„¤ì •
        self.establish_chemistry(characters)
        
        return characters
    
    def establish_relationships(self, characters: List[Dict]) -> Dict:
        """ìºë¦­í„° ê°„ ì´ˆê¸° ê´€ê³„ ì„¤ì •"""
        relationships = {}
        
        for i, char1 in enumerate(characters):
            for char2 in characters[i+1:]:
                rel_key = f"{char1['name']}-{char2['name']}"
                
                relationships[rel_key] = {
                    "type": self.determine_relationship_type(char1, char2),
                    "initial_state": self.set_initial_state(char1, char2),
                    "potential_development": self.plan_relationship_arc(char1, char2),
                    "conflict_points": self.identify_conflict_points(char1, char2)
                }
        
        return relationships
```

---

## 8. ì—ëŸ¬ ì²˜ë¦¬ ë° ë³µêµ¬

### 8.1 ì—ëŸ¬ ì²˜ë¦¬ ì „ëµ
```python
class ErrorHandler:
    def __init__(self):
        self.error_thresholds = {
            "api_error": 5,
            "network_error": 10,
            "processing_error": 3
        }
        self.recovery_strategies = self.load_recovery_strategies()
    
    def handle_error(self, error_type: str, error_details: Dict):
        """ì—ëŸ¬ ì²˜ë¦¬ ë° ë³µêµ¬"""
        # 1. ì—ëŸ¬ ë¡œê¹…
        self.log_error(error_type, error_details)
        
        # 2. ì„ê³„ê°’ í™•ì¸
        if self.check_threshold_exceeded(error_type):
            self.escalate_error(error_type, error_details)
        
        # 3. ë³µêµ¬ ì „ëµ ì‹¤í–‰
        recovery_strategy = self.get_recovery_strategy(error_type)
        return recovery_strategy.execute(error_details)
```

### 8.2 ë³µêµ¬ ì „ëµ
```python
RECOVERY_STRATEGIES = {
    "api_rate_limit": {
        "strategy": "exponential_backoff",
        "initial_delay": 60,
        "max_delay": 3600,
        "max_retries": 5
    },
    "api_quota_exceeded": {
        "strategy": "switch_account",
        "fallback_accounts": ["account2", "account3"]
    },
    "video_generation_failed": {
        "strategy": "retry_with_different_avatar",
        "fallback_avatars": ["avatar2", "avatar3"]
    },
    "upload_failed": {
        "strategy": "retry_with_compression",
        "compression_levels": [0.9, 0.8, 0.7]
    }
}
```

---

## 9. ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼

### 9.1 ëª¨ë‹ˆí„°ë§ ë©”íŠ¸ë¦­
```python
MONITORING_METRICS = {
    "system": [
        "cpu_usage",
        "memory_usage",
        "disk_usage",
        "network_io"
    ],
    "application": [
        "episodes_created_today",
        "episodes_in_progress",
        "episodes_failed",
        "average_processing_time",
        "api_usage_by_service",
        "total_cost_today"
    ],
    "business": [
        "youtube_views",
        "youtube_subscribers",
        "revenue_today",
        "engagement_rate"
    ]
}
```

### 9.2 ì•Œë¦¼ ì„¤ì •
```python
ALERT_RULES = {
    "critical": {
        "conditions": [
            "error_rate > 10%",
            "api_quota_remaining < 10%",
            "system_disk_usage > 90%"
        ],
        "channels": ["email", "sms", "slack"],
        "recipients": ["admin@example.com"]
    },
    "warning": {
        "conditions": [
            "error_rate > 5%",
            "processing_time > 30min",
            "cost_today > daily_budget * 0.8"
        ],
        "channels": ["email", "slack"],
        "recipients": ["team@example.com"]
    }
}
```

---

## 10. ì„±ëŠ¥ ìµœì í™”

### 10.1 ë³‘ë ¬ ì²˜ë¦¬
```python
class ParallelProcessor:
    def __init__(self, max_workers=4):
        self.executor = ProcessPoolExecutor(max_workers=max_workers)
    
    def process_scenes_parallel(self, scenes: List[Dict]) -> List[str]:
        """ì¥ë©´ë³„ ë³‘ë ¬ ì²˜ë¦¬"""
        futures = []
        
        for scene in scenes:
            future = self.executor.submit(
                self.process_single_scene,
                scene
            )
            futures.append(future)
        
        # ê²°ê³¼ ìˆ˜ì§‘
        results = []
        for future in as_completed(futures):
            try:
                result = future.result(timeout=300)
                results.append(result)
            except TimeoutError:
                self.handle_timeout(future)
        
        return results
```

### 10.2 ìºì‹± ì „ëµ
```python
CACHE_CONFIG = {
    "redis": {
        "host": "localhost",
        "port": 6379,
        "db": 0,
        "decode_responses": True
    },
    "ttl": {
        "character_profiles": 86400,  # 24ì‹œê°„
        "voice_settings": 3600,       # 1ì‹œê°„
        "api_responses": 300,         # 5ë¶„
        "generated_scripts": 0        # ì˜êµ¬ ë³´ê´€
    }
}

@cache.memoize(timeout=CACHE_CONFIG["ttl"]["character_profiles"])
def get_character_profile(character_id: str) -> Dict:
    """ìºì‹œëœ ìºë¦­í„° í”„ë¡œí•„ ì¡°íšŒ"""
    return db.query(
        "SELECT * FROM characters WHERE id = %s",
        (character_id,)
    )
```

---

## 11. ë³´ì•ˆ ì„¤ì •

### 11.1 API í‚¤ ê´€ë¦¬
```python
class SecureConfig:
    def __init__(self):
        self.vault_client = hvac.Client(
            url='http://localhost:8200',
            token=os.environ.get('VAULT_TOKEN')
        )
    
    def get_api_key(self, service: str) -> str:
        """Vaultì—ì„œ API í‚¤ ì¡°íšŒ"""
        secret = self.vault_client.secrets.kv.v2.read_secret_version(
            path=f'api-keys/{service}'
        )
        return secret['data']['data']['key']
    
    def rotate_api_keys(self):
        """API í‚¤ ì •ê¸° êµì²´"""
        services = ['openai', 'elevenlabs', 'heygen', 'youtube']
        for service in services:
            new_key = self.generate_new_key(service)
            self.update_key_in_vault(service, new_key)
```

### 11.2 ì ‘ê·¼ ì œì–´
```python
SECURITY_CONFIG = {
    "authentication": {
        "type": "jwt",
        "secret_key": os.environ.get("JWT_SECRET"),
        "algorithm": "HS256",
        "expire_minutes": 30
    },
    "rate_limiting": {
        "requests_per_minute": 60,
        "requests_per_hour": 1000
    },
    "cors": {
        "allowed_origins": ["http://localhost:3000"],
        "allowed_methods": ["GET", "POST", "PUT", "DELETE"],
        "allowed_headers": ["*"]
    }
}
```

---

## 12. ë°°í¬ ì„¤ì •

### 12.1 Docker êµ¬ì„±
```dockerfile
# Dockerfile
FROM python:3.9-slim

WORKDIR /app

# ì‹œìŠ¤í…œ íŒ¨í‚¤ì§€ ì„¤ì¹˜
RUN apt-get update && apt-get install -y \
    ffmpeg \
    libsm6 \
    libxext6 \
    && rm -rf /var/lib/apt/lists/*

# Python ì˜ì¡´ì„± ì„¤ì¹˜
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# ì• í”Œë¦¬ì¼€ì´ì…˜ ë³µì‚¬
COPY . .

# í™˜ê²½ ë³€ìˆ˜
ENV PYTHONUNBUFFERED=1

# ì‹¤í–‰
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### 12.2 Docker Compose
```yaml
version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/aidrama
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis
    volumes:
      - ./videos:/app/videos
      - ./logs:/app/logs

  worker:
    build: .
    command: celery -A app.workers worker -l info
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/aidrama
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis
    volumes:
      - ./videos:/app/videos

  scheduler:
    build: .
    command: celery -A app.workers beat -l info
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/aidrama
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis

  db:
    image: postgres:13
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
      - POSTGRES_DB=aidrama
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:6-alpine
    ports:
      - "6379:6379"

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - api

volumes:
  postgres_data:
```

---

## 13. í…ŒìŠ¤íŠ¸ ì „ëµ

### 13.1 ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
```python
# tests/test_script_generator.py
import pytest
from app.core.script_generator import ScriptGenerator

class TestScriptGenerator:
    @pytest.fixture
    def generator(self):
        return ScriptGenerator()
    
    def test_generate_episode_script(self, generator, mock_openai):
        """ì—í”¼ì†Œë“œ ëŒ€ë³¸ ìƒì„± í…ŒìŠ¤íŠ¸"""
        # Given
        episode_number = 1
        mock_openai.return_value = {"scenes": [...]}
        
        # When
        result = generator.generate_episode_script(episode_number)
        
        # Then
        assert result["episode_number"] == episode_number
        assert len(result["scenes"]) >= 5
        assert result["total_duration"] >= 9.0
    
    def test_validate_script(self, generator):
        """ëŒ€ë³¸ ìœ íš¨ì„± ê²€ì¦ í…ŒìŠ¤íŠ¸"""
        # Given
        valid_script = {
            "episode_number": 1,
            "title": "ì²« ë§Œë‚¨",
            "scenes": [...]
        }
        
        # When/Then
        assert generator.validate_script(valid_script) == True
```

### 13.2 í†µí•© í…ŒìŠ¤íŠ¸
```python
# tests/test_integration.py
class TestEndToEnd:
    def test_complete_episode_production(self):
        """ì „ì²´ ì—í”¼ì†Œë“œ ì œì‘ í”„ë¡œì„¸ìŠ¤ í…ŒìŠ¤íŠ¸"""
        # 1. ì—í”¼ì†Œë“œ ìƒì„±
        episode = create_test_episode()
        
        # 2. ëŒ€ë³¸ ìƒì„±
        script = generate_script(episode.id)
        assert script is not None
        
        # 3. ìŒì„± ìƒì„±
        voices = generate_voices(script)
        assert len(voices) > 0
        
        # 4. ì˜ìƒ ìƒì„±
        videos = generate_videos(script, voices)
        assert len(videos) == len(script["scenes"])
        
        # 5. í¸ì§‘
        final_video = edit_episode(videos)
        assert os.path.exists(final_video)
        
        # 6. ì—…ë¡œë“œ (í…ŒìŠ¤íŠ¸ ëª¨ë“œ)
        youtube_id = upload_to_youtube(final_video, test_mode=True)
        assert youtube_id is not None
```

---

## 14. ìš´ì˜ ë§¤ë‰´ì–¼

### 14.1 ì¼ì¼ ì ê²€ ì‚¬í•­
```yaml
ì¼ì¼ ì ê²€ ì²´í¬ë¦¬ìŠ¤íŠ¸:
  ì‹œìŠ¤í…œ:
    - [ ] ì„œë²„ ìƒíƒœ í™•ì¸
    - [ ] ë””ìŠ¤í¬ ìš©ëŸ‰ í™•ì¸ (80% ë¯¸ë§Œ)
    - [ ] ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  í™•ì¸
    - [ ] API ì”ì•¡ í™•ì¸
  
  ì œì‘:
    - [ ] ì˜¤ëŠ˜ ì œì‘ ì˜ˆì • ì—í”¼ì†Œë“œ í™•ì¸
    - [ ] ì§„í–‰ ì¤‘ì¸ ì‘ì—… ìƒíƒœ í™•ì¸
    - [ ] ì‹¤íŒ¨í•œ ì‘ì—… ì¬ì‹œë„
    - [ ] YouTube ì—…ë¡œë“œ í™•ì¸
  
  í’ˆì§ˆ:
    - [ ] ìƒì„±ëœ ì˜ìƒ ìƒ˜í”Œ í™•ì¸
    - [ ] ìë§‰ ì •í™•ë„ í™•ì¸
    - [ ] ìŒì„± í’ˆì§ˆ í™•ì¸
    - [ ] ëŒ“ê¸€ ë° í”¼ë“œë°± í™•ì¸
```

### 14.2 ë¬¸ì œ í•´ê²° ê°€ì´ë“œ
```yaml
ì¼ë°˜ì ì¸ ë¬¸ì œ í•´ê²°:
  API í•œë„ ì´ˆê³¼:
    - ëŒ€ì²´ API í‚¤ë¡œ ì „í™˜
    - ì¼ì¼ ì œì‘ëŸ‰ ì¡°ì •
    - ë‹¤ìŒë‚ ê¹Œì§€ ëŒ€ê¸°
  
  ì˜ìƒ ìƒì„± ì‹¤íŒ¨:
    - ì•„ë°”íƒ€ ë³€ê²½ í›„ ì¬ì‹œë„
    - ìŒì„± íŒŒì¼ ê²€ì¦
    - ìˆ˜ë™ ìƒì„± í›„ ì—…ë¡œë“œ
  
  ì—…ë¡œë“œ ì‹¤íŒ¨:
    - ë„¤íŠ¸ì›Œí¬ ì—°ê²° í™•ì¸
    - YouTube API ìƒíƒœ í™•ì¸
    - ì˜ìƒ í¬ê¸° ì¶•ì†Œ í›„ ì¬ì‹œë„
```

---

## 15. ë¹„ìš© ìµœì í™”

### 15.1 API ì‚¬ìš© ìµœì í™”
```python
class CostOptimizer:
    def __init__(self):
        self.cost_limits = {
            "daily_total": 100.0,  # $100
            "openai": 50.0,
            "elevenlabs": 20.0,
            "heygen": 30.0
        }
    
    def optimize_api_usage(self):
        """API ì‚¬ìš© ìµœì í™”"""
        # 1. í˜„ì¬ ì‚¬ìš©ëŸ‰ í™•ì¸
        current_usage = self.get_current_usage()
        
        # 2. í•œë„ ì´ˆê³¼ ì˜ˆìƒì‹œ ì¡°ì •
        if self.predict_overage(current_usage):
            self.adjust_production_rate()
            self.switch_to_cheaper_options()
```

### 15.2 ë¦¬ì†ŒìŠ¤ ìµœì í™”
```python
OPTIMIZATION_RULES = {
    "script_length": {
        "target_words": 1500,  # 10ë¶„ ê¸°ì¤€
        "tolerance": 100
    },
    "video_quality": {
        "resolution": "720p",  # 1080p ëŒ€ì‹ 
        "bitrate": "3000k"    # 5000k ëŒ€ì‹ 
    },
    "batch_processing": {
        "batch_size": 5,      # ë™ì‹œ ì²˜ë¦¬ ìˆ˜
        "delay_between": 60   # ë°°ì¹˜ ê°„ ëŒ€ê¸° ì‹œê°„
    }
}
```

---

ì´ ê°œë°œ ì§€ì‹œì„œë¥¼ ê°œë°œìì—ê²Œ ì „ë‹¬í•˜ì‹œë©´, ì‹œìŠ¤í…œ êµ¬ì¶•ì— í•„ìš”í•œ ëª¨ë“  ê¸°ìˆ ì  ì„¸ë¶€ì‚¬í•­ì„ ì´í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì¶”ê°€ë¡œ í•„ìš”í•œ ë¶€ë¶„ì´ë‚˜ ë” ìƒì„¸í•œ ì„¤ëª…ì´ í•„ìš”í•œ ë¶€ë¶„ì´ ìˆìœ¼ì‹œë©´ ë§ì”€í•´ì£¼ì„¸ìš”.